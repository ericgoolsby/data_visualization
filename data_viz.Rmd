---
title: "Data Visualization: Part 1"
author: "Adapted from Claus Wilke"
date: "11/17/2021"
output:
  bookdown::html_document2:
    code_folding: hide
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
options(digits = 3)
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  cache = FALSE,
  #dpi = 105, # not sure why, but need to divide this by 2 to get 210 at 6in, which is 300 at 4.2in
  fig.align = 'left',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold"
)

options(dplyr.print_min = 6, dplyr.print_max = 6)

main_size = 14 / 2.845276
small_rel <- 12/14
small_size <- small_rel * main_size
```

Code for figures from Claus Wilke's *Fundamentals of Data Visaulization* ([book](https://clauswilke.com/dataviz/) \| [source code](https://github.com/clauswilke/dataviz)).

First, install (if needed) and then load the following packages. RStudio should prompt you to install the ones you need, but if not, run the installation code for the packages you do not have installed.
```{r}
library(tidyverse)
#install.packages("devtools")
library(devtools)

#install.packages("bookdown")
library(bookdown)

#install.packages("emmeans")
library(emmeans)

#install.packages("broom")
library(broom)

#install.packages("treemapify")
library(treemapify)

#install.packages("cowplot")
# or
#devtools::install_github("wilkelab/cowplot")
library(cowplot)

#install.packages("ggridges")
# or
#devtools::install_github("wilkelab/ggridges")
library(ggridges)

#install.packages("lubridate")
library(lubridate)

#devtools::install_github("thomasp85/ggforce", force = TRUE)
#devtools::install_github("thomasp85/patchwork")
library(ggforce)
library(patchwork)

#install.packages("colorspace")
library(colorspace)

#install.packages("gapminder")
library(gapminder)

#devtools::install_github("clauswilke/colorblindr")
library(colorblindr)
#https://rdrr.io/github/clauswilke/dviz.supp/
#devtools::install_github("clauswilke/dviz.supp")
library(dviz.supp)
```

## Amounts

### Bar charts

```{r}
boxoffice <- data.frame(rank = 1:5,
                        title = c("Star Wars: The Last Jedi", "Jumanji: Welcome to the Jungle", "Pitch Perfect 3", "The Greatest Showman", "Ferdinand"),
                        title_short = c("Star Wars", "Jumanji", "Pitch Perfect 3", "Greatest Showman", "Ferdinand"),
                        amount = c(71565498, 36169328, 19928525, 8805843, 7316746),
                        amount_text = c("$71,565,498", "$36,169,328", "$19,928,525", "$8,805,843", "$7,316,746"))

knitr::kable(
  boxoffice,
  caption = 'Highest grossing movies for the weekend of December 22-24, 2017. Data source: Box Office Mojo (http://www.boxofficemojo.com/). Used with permission', booktabs = TRUE,
  row.names = FALSE,
  align = c('c', 'c', 'l', 'r', 'c', 'c')#,
  #format = "html",
  #table.attr = "style = \"width: 75%\""
)
```

(ref:boxoffice-vertical) Highest grossing movies for the weekend of December 22-24, 2017, displayed as a bar plot. Data source: Box Office Mojo (http://www.boxofficemojo.com/). Used with permission
```{r boxoffice-vertical, fig.width = 5*6/4.2, fig.asp = .5, fig.cap = '(ref:boxoffice-vertical)'}
boxoffice %>%
  ggplot(aes(x = fct_reorder(title_short, rank), y = amount)) +
    geom_col(fill = "#56B4E9", width = 0.6, alpha = 0.9) +
    scale_y_continuous(expand = c(0, 0),
                       breaks = c(0, 2e7, 4e7, 6e7),
                       labels = c("0", "20", "40", "60"),
                       name = "weekend gross (million USD)") +
    scale_x_discrete(name = NULL,
                     expand = c(0, 0.4)) +
    coord_cartesian(clip = "off") +
    theme_dviz_hgrid(12, rel_small = 1) +
    theme(
      #axis.ticks.length = grid::unit(0, "pt"),
      axis.line.x = element_blank(),
      axis.ticks.x = element_blank()
    )
```

(ref:boxoffice-rot-axis-tick-labels) Highest grossing movies for the weekend of December 22-24, 2017, displayed as a bar plot with rotated axis tick labels. Rotated axis tick labels tend to be difficult to read and require awkward space use underneath the plot. For these reasons, I generally consider plots with rotated tick labels to be ugly. Data source: Box Office Mojo (http://www.boxofficemojo.com/). Used with permission
```{r boxoffice-rot-axis-tick-labels, fig.asp = 0.85, fig.cap = '(ref:boxoffice-rot-axis-tick-labels)'}
boxoffice %>%
  ggplot(aes(x = fct_reorder(title_short, rank), y = amount)) +
    geom_col(fill = "#56B4E9", alpha = 0.9) +
    scale_y_continuous(expand = c(0, 0),
                       breaks = c(0, 2e7, 4e7, 6e7),
                       labels = c("0", "20", "40", "60"),
                       name = "weekend gross (million USD)") +
    scale_x_discrete(name = NULL) +
    coord_cartesian(clip = "off") +
    theme_dviz_hgrid(rel_small = 1) +
    theme(
      #axis.ticks.length = grid::unit(0, "pt"),
      axis.line.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
      plot.margin = margin(3, 7, 3, 1.5)
    ) -> p_box_axrot
stamp_ugly(p_box_axrot)
```

(ref:boxoffice-horizontal-bad-order) Highest grossing movies for the weekend of December 22-24, 2017, displayed as a horizontal bar plot. Here, the bars have been placed in descending order of the lengths of the movie titles. This arrangement of bars is arbitrary, it doesn't serve a meaningful purpose, and it makes the resulting figure much less intuitive than Figure \@ref(fig:boxoffice-horizontal). Data source: Box Office Mojo (http://www.boxofficemojo.com/). Used with permission
```{r boxoffice-horizontal-bad-order, fig.cap = '(ref:boxoffice-horizontal-bad-order)'}
p <- ggplot(boxoffice, aes(x = factor(title_short, levels = title_short[c(2, 1, 5, 3, 4)]),
                           y = amount)) +
  geom_col(fill = "#56B4E9", alpha = 0.9) +
  scale_y_continuous(limits = c(0, 7.5e7),
                     expand = c(0, 0),
                     breaks = c(0, 2e7, 4e7, 6e7),
                     labels = c("0", "20", "40", "60"),
                     name = "weekend gross (million USD)") +
  scale_x_discrete(name = NULL,
                   expand = c(0, 0.5)) +
  coord_flip(clip = "off") +
  theme_dviz_vgrid(rel_small = 1) +
  theme(
    #axis.ticks.length = grid::unit(0, "pt"),
    axis.line.y = element_blank(),
    axis.ticks.y = element_blank()
  )
stamp_bad(p)
```

(ref:boxoffice-horizontal) Highest grossing movies for the weekend of December 22-24, 2017, displayed as a horizontal bar plot. Data source: Box Office Mojo (http://www.boxofficemojo.com/). Used with permission
```{r boxoffice-horizontal, fig.cap = '(ref:boxoffice-horizontal)'}
ggplot(boxoffice, aes(x = fct_reorder(title_short, desc(rank)), y = amount)) +
  geom_col(fill = "#56B4E9", alpha = 0.9) +
  scale_y_continuous(limits = c(0, 7.5e7),
                     expand = c(0, 0),
                     breaks = c(0, 2e7, 4e7, 6e7),
                     labels = c("0", "20", "40", "60"),
                     name = "weekend gross (million USD)") +
  scale_x_discrete(name = NULL,
                   expand = c(0, 0.5)) +
  coord_flip(clip = "off") +
  theme_dviz_vgrid(rel_small = 1) +
  theme(
    #axis.ticks.length = grid::unit(0, "pt"),
    axis.line.y = element_blank(),
    axis.ticks.y = element_blank()
  )
```

(ref:income-by-age) 2016 median U.S. annual household income versus age group. The 45--54 year age group has the highest median income. Data source: United States Census Bureau
```{r income-by-age, fig.cap = '(ref:income-by-age)'}
income_by_age %>% filter(race == "all") %>%
  ggplot(aes(x = age, y = median_income)) +
    geom_col(fill = "#56B4E9", alpha = 0.9) +
    scale_y_continuous(expand = c(0, 0),
                       name = "median income (USD)",
                       breaks = c(0, 20000, 40000, 60000),
                       labels = c("$0", "$20,000", "$40,000", "$60,000")) +
    xlab("age (years)") +
    coord_cartesian(clip = "off") +
    theme_dviz_hgrid() +
    theme(
      #axis.ticks.length = grid::unit(0, "pt"),
      axis.ticks.x = element_blank(),
      axis.line = element_blank(),
      plot.margin = margin(3, 7, 3, 1.5)
    )
```

(ref:income-by-age-sorted) 2016 median U.S. annual household income versus age group, sorted by income. While this order of bars looks visually appealing, the order of the age groups is now confusing. Data source: United States Census Bureau
```{r income-by-age-sorted, fig.cap = '(ref:income-by-age-sorted)'}
income_by_age %>% filter(race == "all") %>%
  ggplot(aes(x = fct_reorder(age, desc(median_income)), y = median_income)) +
    geom_col(fill = "#56B4E9", alpha = 0.9) +
    scale_y_continuous(
      expand = c(0, 0),
      name = "median income (USD)",
      breaks = c(0, 20000, 40000, 60000),
      labels = c("$0", "$20,000", "$40,000", "$60,000")
    ) +
    coord_cartesian(clip = "off") +
    xlab("age (years)") +
    theme_dviz_hgrid() +
    theme(
      #axis.ticks.length = grid::unit(0, "pt"),
      axis.ticks.x = element_blank(),
      axis.line = element_blank(),
      plot.margin = margin(3, 7, 3, 1.5)
    ) -> p_income_sorted
stamp_bad(p_income_sorted)
```

### Dot plots

(ref:Americas-life-expect) Life expectancies of countries in the Americas, for the year 2007. Data source: Gapminder project
```{r Americas-life-expect, fig.width = 6., fig.asp = .9, fig.cap = '(ref:Americas-life-expect)'}
library(gapminder)
df_Americas <- gapminder %>% filter(year == 2007, continent == "Americas")
ggplot(df_Americas, aes(x = lifeExp, y = fct_reorder(country, lifeExp))) +
  geom_point(color = "#0072B2", size = 3) +
  scale_x_continuous(
    name = "life expectancy (years)",
    limits = c(59.7, 81.5),
    expand = c(0, 0)
  ) +
  scale_y_discrete(name = NULL, expand = c(0, 0.5)) +
  theme_dviz_grid(12, rel_small = 1) +
  theme(
    #axis.ticks.length = grid::unit(0, "pt"),
    #axis.title = element_text(size = 12),
    plot.margin = margin(18, 6, 3, 1.5)
  )
```

(ref:Americas-life-expect-bad) Life expectancies of countries in the Americas, for the year 2007. Here, the countries are ordered alphabetically, which causes a dots to form a disordered cloud of points. This makes the figure difficult to read, and therefore it deserves to be labeled as "bad." Data source: Gapminder project
```{r Americas-life-expect-bad, fig.width = 6., fig.asp = .9, fig.cap = '(ref:Americas-life-expect-bad)'}
p <- ggplot(df_Americas, aes(x = lifeExp, y = fct_rev(country))) +
  geom_point(color = "#0072B2", size = 3) +
  scale_x_continuous(name = "life expectancy (years)",
                     limits = c(59.7, 81.5),
                     expand = c(0, 0)) +
  scale_y_discrete(name = NULL, expand = c(0, 0.5)) +
  theme_dviz_grid(12, rel_small = 1) +
  theme(#axis.ticks.length = grid::unit(0, "pt"),
        #axis.title = element_text(size = 12),
        plot.margin = margin(18, 6, 3, 1.5))
stamp_bad(p)
```

(ref:Americas-life-expect-bars) Life expectancies of countries in the Americas, for the year 2007, shown as bars. This dataset is not suitable for being visualized with bars. The bars are too long and they draw attention away from the key feature of the data, the differences in life expectancy among the different countries. Data source: Gapminder project
```{r Americas-life-expect-bars, fig.width = 6., fig.asp = .9, fig.cap = '(ref:Americas-life-expect-bars)'}
life_bars <- ggplot(df_Americas, aes(y = lifeExp, x = fct_reorder(country, lifeExp))) +
  geom_col(fill = "#56B4E9", alpha = 0.9) +
  scale_y_continuous(
    name = "life expectancy (years)",
    limits = c(0, 85),
    expand = c(0, 0)
  ) +
  scale_x_discrete(name = NULL, expand = c(0, 0.5)) +
  coord_flip(clip = "off") +
  theme_dviz_vgrid(12, rel_small = 1) +
  theme(
    #axis.ticks.length = grid::unit(0, "pt"),
    axis.line.y = element_blank(),
    axis.ticks.y = element_blank(),
    #axis.title = element_text(size = 12),
    plot.margin = margin(18, 6, 3, 1.5)
  )
stamp_bad(life_bars)
```

### Heat maps

(ref:internet-over-time) Internet adoption over time, for select countries. Color represents the percent of internet users for the respective country and year. Countries were ordered by percent internet users in 2016. Data source: World Bank
```{r internet-over-time, fig.width = 5.5*6/4.2, fig.cap = '(ref:internet-over-time)'}
country_list = c("United States", "China", "India", "Japan", "Algeria",
                 "Brazil", "Germany", "France", "United Kingdom", "Italy", "New Zealand",
                 "Canada", "Mexico", "Chile", "Argentina", "Norway", "South Africa", "Kenya",
                 "Israel", "Iceland")
internet_short <- filter(internet, country %in% country_list) %>%
  mutate(users = ifelse(is.na(users), 0, users))
internet_summary <- internet_short %>%
  group_by(country) %>%
  summarize(year1 = min(year[users > 0]),
            last = users[n()]) %>%
  arrange(last, desc(year1))
internet_short <- internet_short %>%
  mutate(country = factor(country, levels = internet_summary$country))
ggplot(filter(internet_short, year > 1993),
       aes(x = year, y = country, fill = users)) +
  geom_tile(color = "white", size = 0.25) +
  scale_fill_viridis_c(
    option = "A", begin = 0.05, end = 0.98,
    limits = c(0, 100),
    name = "internet users / 100 people",
    guide = guide_colorbar(
      direction = "horizontal",
      label.position = "bottom",
      title.position = "top",
      ticks = FALSE,
      barwidth = grid::unit(3.5, "in"),
      barheight = grid::unit(0.2, "in")
    )
  ) +
  scale_x_continuous(expand = c(0, 0), name = NULL) +
  scale_y_discrete(name = NULL, position = "right") +
  theme_dviz_open(12) +
  theme(
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    axis.ticks.length = grid::unit(1, "pt"),
    legend.position = "top",
    legend.justification = "left",
    legend.title.align = 0.5,
    legend.title = element_text(size = 12*12/14)
  )
```

(ref:internet-over-time2) Internet adoption over time, for select countries. Countries were ordered by the year in which their internet usage first exceeded 20%. Data source: World Bank
```{r internet-over-time2, fig.width = 5.5*6/4.2, fig.cap = '(ref:internet-over-time2)'}
internet_summary <- internet_short %>%
  group_by(country) %>%
  summarize(year1 = min(year[users > 20]),
            last = users[n()]) %>%
  arrange(desc(year1), last)
internet_short <- internet_short %>%
  mutate(country = factor(country, levels = internet_summary$country))
ggplot(filter(internet_short, year > 1993),
       aes(x = year, y = country, fill = users)) +
  geom_tile(color = "white", size = 0.25) +
  scale_fill_viridis_c(
    option = "A", begin = 0.05, end = 0.98,
    limits = c(0, 100),
    name = "internet users / 100 people",
    guide = guide_colorbar(
      direction = "horizontal",
      label.position = "bottom",
      title.position = "top",
      ticks = FALSE,
      barwidth = grid::unit(3.5, "in"),
      barheight = grid::unit(0.2, "in")
    )
  ) +
  scale_x_continuous(expand = c(0, 0), name = NULL) +
  scale_y_discrete(name = NULL, position = "right") +
  theme_dviz_open(12) +
  theme(
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    axis.ticks.length = grid::unit(1, "pt"),
    legend.position = "top",
    legend.justification = "left",
    legend.title.align = 0.5,
    legend.title = element_text(size = 12*12/14)
  )
```

## Distributions

```{r titanic-ages}
titanic <- titanic_all
age_counts <- hist(titanic$age, breaks = (0:15) * 5 + .01, plot = FALSE)$counts
age_hist <- data.frame(
  `age range` = c("0--5", "6--10", "11--15", "16--20", "21--25", "26--30", "31--35", "36--40", "41--45", "46--50", "51--55", "56--60", "61--65", "66--70", "71--75"),
  count = age_counts,
  check.names = FALSE
)
age_hist_display <- rename(
  age_hist,
  `Age range` = `age range`,
  Count = count
)
knitr::kable(
  list(
    age_hist_display[1:6,], age_hist_display[7:12,], age_hist_display[13:15,]
  ),
  caption = 'Numbers of passenger with known age on the Titanic.', booktabs = TRUE,
  row.names = FALSE
)
```

### Histograms

(ref:titanic-ages-hist1) Histogram of the ages of Titanic passengers.
```{r titanic-ages-hist1, fig.cap='(ref:titanic-ages-hist1)'}
age_hist <- cbind(age_hist, age = (1:15) * 5 - 2.5)
h1 <- ggplot(age_hist, aes(x = age, y = count)) + geom_col(width = 4.7, fill = "#56B4E9")  + 
  scale_y_continuous(expand = c(0, 0), breaks = 25 * (0:5)) +
  scale_x_continuous(name = "age (years)", limits = c(0, 75), expand = c(0, 0)) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid() +
  theme(
    axis.line.x = element_blank(),
    plot.margin = margin(3, 7, 3, 1.5)
  )
h1
```


(ref:titanic-ages-hist-grid) Histograms depend on the chosen bin width. Here, the same age distribution of Titanic passengers is shown with four different bin widths: (a) one year; (b) three years; (c) five years; (d) fifteen years. For the age distribution of Titanic passengers, we can see that a bin width of one year is too small and a bin width of fifteen years is too large, whereas bin widths between three to five years work fine:
```{r titanic-ages-hist-grid, fig.width=5.5*6/4.2, fig.cap='(ref:titanic-ages-hist-grid)'}
age_hist_1 <- data.frame(
  age = (1:75) - 0.5, 
  count = hist(titanic$age, breaks = (0:75) + .01, plot = FALSE)$counts
)
age_hist_3 <- data.frame(
  age = (1:25) * 3 - 1.5, 
  count = hist(titanic$age, breaks = (0:25) * 3 + .01, plot = FALSE)$counts
)
age_hist_15 <- data.frame(
  age = (1:5) * 15 - 7.5, 
  count = hist(titanic$age, breaks = (0:5) * 15 + .01, plot = FALSE)$counts
)
h2 <- ggplot(age_hist_1, aes(x = age, y = count)) + 
  geom_col(width = .85, fill = "#56B4E9")  + 
  scale_y_continuous(expand = c(0, 0), breaks = 10 * (0:5)) +
  scale_x_continuous(name = "age (years)", limits = c(0, 75), expand = c(0, 0)) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid(12) +
  theme(
    axis.line.x = element_blank(),
    plot.margin = margin(3, 1.5, 3, 1.5)
  )
h3 <- ggplot(age_hist_3, aes(x = age, y = count)) + geom_col(width = 2.75, fill = "#56B4E9")  + 
  scale_y_continuous(expand = c(0, 0), breaks = 25 * (0:5)) +
  scale_x_continuous(name = "age (years)", limits = c(0, 75), expand = c(0, 0)) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid(12) +
  theme(
    axis.line.x = element_blank(),
    plot.margin = margin(3, 1.5, 3, 1.5)
  )
h4 <- ggplot(age_hist_15, aes(x = age, y = count)) + geom_col(width = 14.5, fill = "#56B4E9")  + 
  scale_y_continuous(expand = c(0, 0), breaks = 100 * (0:4)) +
  scale_x_continuous(name = "age (years)", limits = c(0, 75), expand = c(0, 0)) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid(12) +
  theme(
    axis.line.x = element_blank(),
    plot.margin = margin(3, 1.5, 3, 1.5)
  )
plot_grid(
  h2, NULL, h3,
  NULL, NULL, NULL,
  h1 + theme_dviz_hgrid(12) + theme(axis.line.x = element_blank(), plot.margin = margin(3, 1.5, 3, 1.5)),
  NULL, h4,
  align = 'hv',
  labels = c("a", "", "b", "", "", "", "c", "", "d"),
  rel_widths = c(1, .04, 1),
  rel_heights = c(1, .04, 1)
)
```

(ref:titanic-ages-dens1) Kernel density estimate of the age distribution of passengers on the Titanic. The height of the curve is scaled such that the area under the curve equals one. The density estimate was performed with a Gaussian kernel and a bandwidth of 2.

```{r titanic-ages-dens1, fig.cap='(ref:titanic-ages-dens1)'}
ggplot(titanic, aes(x = age)) + 
  geom_density_line(fill = "#56B4E9", color = darken("#56B4E9", 0.5), bw = 2, kernel = "gaussian") + 
  scale_y_continuous(limits = c(0, 0.046), expand = c(0, 0), name = "density") +
  scale_x_continuous(name = "age (years)", limits = c(0, 75), expand = c(0, 0)) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid() +
  theme(
    axis.line.x = element_blank(),
    plot.margin = margin(3, 7, 3, 1.5)
  )
```

(ref:titanic-ages-dens-grid) Kernel density estimates depend on the chosen kernel and bandwidth. Here, the same age distribution of Titanic passengers is shown for four different combinations of these parameters: (a) Gaussian kernel, bandwidth = 0.5; (b) Gaussian kernel, bandwidth = 2; (c) Gaussian kernel, bandwidth = 5; (d) Rectangular kernel, bandwidth = 2.

```{r titanic-ages-dens-grid, fig.width=5.5*6/4.2, fig.cap='(ref:titanic-ages-dens-grid)'}
pdens1 <- ggplot(titanic, aes(x = age)) + 
  geom_density_line(fill = "#56B4E9", color = darken("#56B4E9", 0.5), bw = .5, kernel = "gaussian") + 
  scale_y_continuous(limits = c(0, 0.046), expand = c(0, 0), name = "density") +
  scale_x_continuous(name = "age (years)", limits = c(0, 75), expand = c(0, 0)) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid(12) +
  theme(
    axis.line.x = element_blank(),
    plot.margin = margin(3, 1.5, 3, 1.5)
  )
pdens2 <- ggplot(titanic, aes(x = age)) + 
  geom_density_line(fill = "#56B4E9", color = darken("#56B4E9", 0.5), bw = 2, kernel = "gaussian") + 
  scale_y_continuous(limits = c(0, 0.046), expand = c(0, 0), name = "density") +
  scale_x_continuous(name = "age (years)", limits = c(0, 75), expand = c(0, 0)) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid(12) +
  theme(
    axis.line.x = element_blank(),
    plot.margin = margin(3, 1.5, 3, 1.5)
  )
pdens3 <- ggplot(titanic, aes(x = age)) + 
  geom_density_line(fill = "#56B4E9", color = darken("#56B4E9", 0.5), bw = 5, kernel = "gaussian") + 
  scale_y_continuous(limits = c(0, 0.046), expand = c(0, 0), name = "density") +
  scale_x_continuous(name = "age (years)", limits = c(0, 75), expand = c(0, 0)) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid(12) +
  theme(
    axis.line.x = element_blank(),
    plot.margin = margin(3, 1.5, 3, 1.5)
  )
pdens4 <- ggplot(titanic, aes(x = age)) + 
  geom_density_line(fill = "#56B4E9", color = darken("#56B4E9", 0.5), bw = 2, kernel = "rectangular") + 
  scale_y_continuous(limits = c(0, 0.046), expand = c(0, 0), name = "density") +
  scale_x_continuous(name = "age (years)", limits = c(0, 75), expand = c(0, 0)) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid(12) +
  theme(
    axis.line.x = element_blank(),
    plot.margin = margin(3, 1.5, 3, 1.5)
  )
plot_grid(
  pdens1, NULL, pdens2, 
  NULL, NULL, NULL,
  pdens3, NULL, pdens4,
  align = 'hv',
  labels = c("a", "", "b", "", "", "", "c", "", "d"),
  rel_widths = c(1, .04, 1),
  rel_heights = c(1, .04, 1)
)
```

Kernel density estimates have one pitfall that we need to be aware of: They have a tendency to produce the appearance of data where none exists, in particular in the tails. As a consequence, careless use of density estimates can easily lead to figures that make nonsensical statements. For example, if we don't pay attention, we might generate a visualization of an age distribution that includes negative ages (Figure \@ref(fig:titanic-ages-dens-negative)).


(ref:titanic-ages-dens-negative) Kernel density estimates can extend the tails of the distribution into areas where no data exist and no data are even possible. Here, the density estimate has been allowed to extend into the negative age range. This is clearly nonsensical and should be avoided.

```{r titanic-ages-dens-negative, fig.cap='(ref:titanic-ages-dens-negative)'}
pdens_neg <- ggplot(titanic, aes(x = age)) + 
  geom_density_line(fill = "#56B4E9", color = darken("#56B4E9", 0.5)) + 
  scale_y_continuous(limits = c(0, 0.046), expand = c(0, 0), name = "density") +
  scale_x_continuous(name = "age (years)", limits = c(-10, 79), expand = c(0, 0)) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid() +
  theme(
    axis.line.x = element_blank(),
    plot.margin = margin(3, 7, 3, 1.5)
  )
stamp_wrong(pdens_neg)
```

```{block type='rmdtip', echo=TRUE}
Always verify that your density estimate does not predict the existence of nonsensical data values.
```

## Multiple distributions

(ref:titanic-age-stacked-hist) Histogram of the ages of Titanic passengers stratified by gender. This figure has been labeled as "bad" because stacked histograms are easily confused with overlapping histograms (see also Figure \@ref(fig:titanic-age-overlapping-hist)). In addition, the heights of the bars representing female passengers cannot easily be compared to each other.

```{r titanic-age-stacked-hist, fig.cap='(ref:titanic-age-stacked-hist)'}
data.frame(
  age = (1:25)*3 - 1.5, 
  male = hist(filter(titanic, sex == "male")$age, breaks = (0:25)*3 + .01, plot = FALSE)$counts,
  female = hist(filter(titanic, sex == "female")$age, breaks = (0:25)*3 + .01, plot = FALSE)$counts
) %>%
  gather(gender, count, -age) -> gender_counts
gender_counts$gender <- factor(gender_counts$gender, levels = c("female", "male"))
p_hist_stacked <- ggplot(gender_counts, aes(x = age, y = count, fill = gender)) + 
  geom_col(position = "stack") +
  scale_x_continuous(name = "age (years)", limits = c(0, 75), expand = c(0, 0)) +
  scale_y_continuous(limits = c(0, 89), expand = c(0, 0), name = "count") +
  scale_fill_manual(values = c("#D55E00", "#0072B2")) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid() +
  theme(
    axis.line.x = element_blank(),
    legend.position = c(.9, .87),
    legend.justification = c("right", "top"),
    legend.box.background = element_rect(fill = "white", color = "white"),
    plot.margin = margin(3, 7, 3, 1.5)
  )
stamp_bad(p_hist_stacked)
```

In my opinion, this type of visualization should be avoided. There are two key problems here: First, from just looking at the figure, it is never entirely clear where exactly the bars begin. Do they start where the color changes or are they meant to start at zero? In other words, are there about 25 females of age 18--20 or are there almost 80? (The former is the case.) Second, the bar heights for the female counts cannot be directly compared to each other, because the bars all start at a different height. For example, the men were on average older than the women, and this fact is not at all visible in Figure \@ref(fig:titanic-age-stacked-hist).

We could try to address these problems by having all bars start at zero and making the bars partially transparent (Figure \@ref(fig:titanic-age-overlapping-hist)).

(ref:titanic-age-overlapping-hist) Age distributions of male and female Titanic passengers, shown as two overlapping histograms. This figure has been labeled as "bad" because there is no clear visual indication that all blue bars start at a count of 0.

```{r titanic-age-overlapping-hist, fig.cap='(ref:titanic-age-overlapping-hist)'}
p_hist_overlapped <- ggplot(gender_counts, aes(x = age, y = count, fill = gender)) + 
  geom_col(position = "identity", alpha = 0.7) +
  scale_x_continuous(name = "age (years)", limits = c(0, 75), expand = c(0, 0)) +
  scale_y_continuous(limits = c(0, 56), expand = c(0, 0), name = "count") +
  scale_fill_manual(
    values = c("#D55E00", "#0072B2"),
    guide = guide_legend(reverse = TRUE)
  ) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid() +
  theme(
    axis.line.x = element_blank(),
    legend.position = c(.9, .87),
    legend.justification = c("right", "top"),
    legend.box.background = element_rect(fill = "white", color = "white"),
    plot.margin = margin(3, 7, 3, 1.5)
  )
stamp_bad(p_hist_overlapped)
```

However, this approach generates new problems. Now it appears that there are actually three different groups, not just two, and we're still not entirely sure where each bar starts and ends. Overlapping histograms don't work well because a semi-transparent bar drawn on top of another tends to not look like a semi-transparent bar but instead like a bar drawn in a different color.

Overlapping density plots don't typically have the problem that overlapping histograms have, because the continuous density lines help the eye keep the distributions separate. However, for this particular dataset, the age distributions for male and female passengers are nearly identical up to around age 17 and then diverge, so that the resulting visualization is still not ideal (Figure \@ref(fig:titanic-age-overlapping-dens)). 

(ref:titanic-age-overlapping-dens) Density estimates of the ages of male and female Titanic passengers. To highlight that there were more male than female passengers, the density curves were scaled such that the area under each curve corresponds to the total number of male and female passengers with known age (468 and 288, respectively).

```{r titanic-age-overlapping-dens, fig.cap='(ref:titanic-age-overlapping-dens)'}
titanic2 <- titanic
titanic2$sex <- factor(titanic2$sex, levels = c("male", "female"))
ggplot(titanic2, aes(x = age, y = ..count.., fill = sex, color = sex)) + 
  geom_density_line(bw = 2, alpha = 0.7) +
  scale_x_continuous(name = "age (years)", limits = c(0, 75), expand = c(0, 0)) +
  scale_y_continuous(limits = c(0, 19), expand = c(0, 0), name = "scaled density") +
  scale_fill_manual(values = c("#0072B2", "#D55E00"), name = "gender") +
  scale_color_manual(values = darken(c("#0072B2", "#D55E00"), 0.5), name = "gender") +
  guides(fill = guide_legend(override.aes = list(linetype = 0))) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid() +
  theme(
    axis.line.x = element_blank(),
    legend.position = c(.9, .87),
    legend.justification = c("right", "top"),
    legend.box.background = element_rect(fill = "white", color = "white"),
    plot.margin = margin(3, 7, 3, 1.5)
  )
```

A solution that works well for this dataset is to show the age distributions of male and female passengers separately, each as a proportion of the overall age distribution (Figure \@ref(fig:titanic-age-fractional-dens)). This visualization shows intuitively and clearly that there were many fewer women than men in the 20--50-year age range on the Titanic.

(ref:titanic-age-fractional-dens) Age distributions of male and female Titanic passengers, shown as proportion of the passenger total. The colored areas show the density estimates of the ages of male and female passengers, respectively, and the gray areas show the overall passenger age distribution.

```{r titanic-age-fractional-dens, fig.width = 5.5*6/4.2, fig.asp = .45, fig.cap='(ref:titanic-age-fractional-dens)'}
ggplot(titanic2, aes(x = age, y = ..count..)) +
  geom_density_line(
    data = select(titanic, -sex), aes(fill = "all passengers"),
    color = "transparent"
  ) + 
  geom_density_line(aes(fill = sex), bw = 2, color = "transparent") +
  scale_x_continuous(limits = c(0, 75), name = "passenger age (years)", expand = c(0, 0)) +
  scale_y_continuous(limits = c(0, 26), name = "scaled density", expand = c(0, 0)) +
  scale_fill_manual(
    values = c("#b3b3b3a0", "#D55E00", "#0072B2"), 
    breaks = c("all passengers", "male", "female"),
    labels = c("all passengers  ", "males  ", "females"),
    name = NULL,
    guide = guide_legend(direction = "horizontal")
  ) +
  coord_cartesian(clip = "off") +
  facet_wrap(~sex, labeller = labeller(sex = function(sex) paste(sex, "passengers"))) +
  theme_dviz_hgrid() +
  theme(
    axis.line.x = element_blank(),
    strip.text = element_text(size = 14, margin = margin(0, 0, 0.2, 0, "cm")),
    legend.position = "bottom",
    legend.justification = "right",
    legend.margin = margin(4.5, 0, 1.5, 0, "pt"),
    legend.spacing.x = grid::unit(4.5, "pt"),
    legend.spacing.y = grid::unit(0, "pt"),
    legend.box.spacing = grid::unit(0, "cm")
  )
```


Finally, when we want to visualize exactly two distributions, we can also make two separate histograms, rotate them by 90 degrees, and have the bars in one histogram point into the opposite direction of the other. This trick is commonly employed when visualizing age distributions, and the resulting plot is usually called an *age pyramid* (Figure \@ref(fig:titanic-age-pyramid)).

(ref:titanic-age-pyramid) The age distributions of male and female Titanic passengers visualized as an age pyramid.

```{r titanic-age-pyramid, fig.cap='(ref:titanic-age-pyramid)'}
ggplot(gender_counts, aes(x = age, y = ifelse(gender == "male",-1, 1)*count, fill = gender)) + 
  geom_col() +
  scale_x_continuous(name = "age (years)", limits = c(0, 75), expand = c(0, 0)) +
  scale_y_continuous(name = "count", breaks = 20*(-2:1), labels = c("40", "20", "0", "20")) +
  scale_fill_manual(values = c("#D55E00", "#0072B2"), guide = "none") +
  draw_text(x = 70, y = -39, "male", hjust = 0) +
  draw_text(x = 70, y = 21, "female", hjust = 0) +
  coord_flip() +
  theme_dviz_grid() +
  theme(axis.title.x = element_text(hjust = 0.61))
```

Importantly, this trick does not work when there are more than two distributions we want to visualize at the same time. For multiple distributions, histograms tend to become highly confusing, whereas density plots work well as long as the distributions are somewhat distinct and contiguous. For example, to visualize the distribution of butterfat percentage among cows from four different cattle breeds, density plots are fine (Figure \@ref(fig:butterfat-densitites)).

(ref:butterfat-densitites) Density estimates of the butterfat percentage in the milk of four cattle breeds. Data Source: Canadian Record of Performance for Purebred Dairy Cattle

```{r butterfat-densitites, fig.cap='(ref:butterfat-densitites)'}
cows %>% 
  mutate(breed = as.character(breed)) %>%
  filter(breed != "Canadian") -> cows_filtered
# compute densities for sepal lengths
cows_dens <- group_by(cows_filtered, breed) %>%
  do(ggplot2:::compute_density(.$butterfat, NULL)) %>%
  rename(butterfat = x)
# get the maximum values
cows_max <- filter(cows_dens, density == max(density)) %>%
  ungroup() %>%
  mutate(
    hjust = c(0, 0, 0, 0),
    vjust = c(0, 0, 0, 0),
    nudge_x = c(-0.2, -0.2, 0.1, 0.23),
    nudge_y = c(0.03, 0.03, -0.2, -0.06) 
  )
cows_p <- ggplot(cows_dens, aes(x = butterfat, y = density, color = breed, fill = breed)) + 
  geom_density_line(stat = "identity") +
  geom_text(
    data = cows_max,
    aes(
      label = breed, hjust = hjust, vjust = vjust,
      color = breed,
      x = butterfat + nudge_x, 
      y = density + nudge_y
    ),
    inherit.aes = FALSE,
    size = 12/2.845276
  ) +
  scale_color_manual(
    values = darken(c("#56B4E9", "#E69F00", "#D55E00", "#009E73"), 0.3),
    breaks = c("Ayrshire", "Guernsey", "Holstein-Friesian", "Jersey"),
    guide = "none"
  ) +
  scale_fill_manual(
    values = c("#56B4E950", "#E69F0050", "#D55E0050", "#009E7350"),
    breaks = c("Ayrshire", "Guernsey", "Holstein-Friesian", "Jersey"),
    guide = "none"
  ) +
  scale_x_continuous(
    expand = c(0, 0),
    labels = scales::percent_format(accuracy = 1, scale = 1),
    name = "butterfat contents"
  ) +
  scale_y_continuous(limits = c(0, 1.99), expand = c(0, 0)) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid() +
  theme(axis.line.x = element_blank())
  
cows_p
```

```{block type='rmdtip', echo=TRUE}
To visualize several distributions at once, kernel density plots will generally work better than histograms.
```

### Error bars

(ref:lincoln-temp-points-errorbars) Mean daily temperatures in Lincoln, Nebraska in 2016. Points represent the average daily mean temperatures for each month, averaged over all days of the month, and error bars represent twice the standard deviation of the daily mean temperatures within each month. This figure has been labeled as "bad" because because error bars are conventionally used to visualize the uncertainty of an estimate, not the variability in a population. Data source: Weather Underground

```{r lincoln-temp-points-errorbars, fig.cap = '(ref:lincoln-temp-points-errorbars)'}
lincoln_weather %>%
  mutate(
    month_short = fct_recode(
      Month,
      Jan = "January",
      Feb = "February",
      Mar = "March",
      Apr = "April",
      May = "May",
      Jun = "June",
      Jul = "July",
      Aug = "August",
      Sep = "September",
      Oct = "October",
      Nov = "November",
      Dec = "December"
    )
  ) %>%
  mutate(month_short = fct_rev(month_short)) -> lincoln_df
lincoln_errbar <- ggplot(lincoln_df, aes(x = month_short, y = `Mean Temperature [F]`)) +
  stat_summary(
    fun.y = mean, fun.ymax = function(x) {mean(x) + 2*sd(x)},
    fun.ymin = function(x) {mean(x) - 2*sd(x)}, geom = "pointrange",
    fatten = 5
  ) +
  xlab("month") + 
  ylab("mean temperature (°F)") +
  theme_dviz_open() +
  theme(plot.margin = margin(3, 7, 3, 1.5))
stamp_bad(lincoln_errbar)
```

### Boxplots

We can address all four shortcomings of Figure \@ref(fig:lincoln-temp-points-errorbars) by using a traditional and commonly used method for visualizing distributions, the boxplot. A boxplot divides the data into quartiles and visualizes them in a standardized manner (Figure \@ref(fig:boxplot-schematic)).

(ref:boxplot-schematic) Anatomy of a boxplot. Shown are a cloud of points (left) and the corresponding boxplot (right). Only the *y* values of the points are visualized in the boxplot. The line in the middle of the boxplot represents the median, and the box encloses the middle 50% of the data. The top and bottom whiskers extend either to the maximum and minimum of the data or to the maximum or minimum that falls within 1.5 times the height of the box, whichever yields the shorter whisker. The distances of 1.5 times the height of the box in either direction are called the upper and the lower fences. Individual data points that fall beyond the fences are referred to as outliers and are usually shown as individual dots.

```{r boxplot-schematic, fig.width = 5*6/4.2, fig.cap = '(ref:boxplot-schematic)'}
set.seed(3423)
y <- c(rnorm(100), 3.4)
s <- boxplot.stats(y)
df <- data.frame(y = c(s$stats, max(y)),
                 x = c(1.03, 1.405, 1.405, 1.405, 1.03, 1.04),
                 label = c("minimum", "first quartile", "median", "third quartile", "maximum within upper fence", "outlier"))
p_boxplot <- ggplot(data.frame(y), aes(x = 1, y = y)) + geom_boxplot(fill = 'grey90') +
  geom_text(data = df, aes(x, y, label = label), hjust = 0,
            size = 14/2.845276, family = dviz_font_family) +
  scale_x_continuous(limits = c(0, 3.5), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-2.55, 3.5), expand = c(0, 0)) +
  theme_nothing()
p_points <- ggplot(data.frame(y), aes(x = 0, y = y)) + 
  geom_point(position = position_jitter(width = .4, height = 0, seed = 320)) +
  scale_x_continuous(limits = c(-1.8, .4), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-2.55, 3.5), expand = c(0, 0)) +
  theme_nothing()
plot_grid(p_points, p_boxplot, rel_widths = c(.65, 1), nrow = 1)
```

Boxplots are simple yet informative, and they work well when plotted next to each other to visualize many distributions at once. For the Lincoln temperature data, using boxplots leads to Figure \@ref(fig:lincoln-temp-boxplots). In that figure, we can now see that temperature is highly skewed in December (most days are moderately cold and a few are extremely cold) and not very skewed at all in some other months, for example in July.

(ref:lincoln-temp-boxplots) Mean daily temperatures in Lincoln, Nebraska, visualized as boxplots.

```{r lincoln-temp-boxplots, fig.cap = '(ref:lincoln-temp-boxplots)'}
lincoln_box <- ggplot(lincoln_df, aes(x = month_short, y = `Mean Temperature [F]`)) +
  geom_boxplot(fill = 'grey90') + 
  xlab("month") + 
  ylab("mean temperature (°F)") +
  theme_dviz_open() +
  theme(plot.margin = margin(3, 7, 3, 1.5))
lincoln_box
```

### Violin plots

(ref:violin-schematic) Anatomy of a violin plot. Shown are a cloud of points (left) and the corresponding violin plot (right). Only the *y* values of the points are visualized in the violin plot. The width of the violin at a given *y* value represents the point density at that *y* value. Technically, a violin plot is a density estimate rotated by 90 degrees and then mirrored. Violins are therefore symmetric. Violins begin and end at the minimum and maximum data values, respectively. The thickest part of the violin corresponds to the highest point density in the dataset.

```{r violin-schematic, fig.width = 5*6/4.2, fig.cap = '(ref:violin-schematic)'}
set.seed(3423)
y <- c(rnorm(100), 3.4)
d <- density(y)
df <- data.frame(y = c(min(y), d$x[which(d$y == max(d$y))], max(y)),
                 x = c(1.1, 1.5, 1.08),
                 label = c("minimum data value", "maximum point density", "maximum data value"))
p_violin <- ggplot(data.frame(y), aes(x = 1, y = y)) + geom_violin(fill = 'grey90') +
  geom_text(data = df, aes(x, y, label = label), hjust = 0,
            size = 14/2.845276, family = dviz_font_family) +
  scale_x_continuous(limits = c(0, 3.5), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-2.55, 3.5), expand = c(0, 0)) +
  theme_nothing()
p_points <- ggplot(data.frame(y), aes(x = 0, y = y)) + 
  geom_point(position = position_jitter(width = .4, height = 0, seed = 320)) +
  scale_x_continuous(limits = c(-1.8, .4), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-2.55, 3.5), expand = c(0, 0)) +
  theme_nothing()
plot_grid(p_points, p_violin, rel_widths = c(.65, 1), nrow = 1)
```

```{block type='rmdtip', echo=TRUE}
Before using violins to visualize distributions, verify that you have sufficiently many data points in each group to justify showing the point densities as smooth lines.
```


When we visualize the Lincoln temperature data with violins, we obtain Figure \@ref(fig:lincoln-temp-violins). We can now see that some months do have moderately bimodal data. For example, the month of November seems to have had two temperature clusters, one around 50 degrees and one around 35 degrees Fahrenheit.


(ref:lincoln-temp-violins) Mean daily temperatures in Lincoln, Nebraska, visualized as violin plots.

```{r lincoln-temp-violins, fig.cap = '(ref:lincoln-temp-violins)'}
lincoln_violin <- ggplot(lincoln_df, aes(x = month_short, y = `Mean Temperature [F]`)) +
  geom_violin(fill = 'grey90') +
  xlab("month") + 
  ylab("mean temperature (°F)") +
  theme_dviz_open() +
  theme(plot.margin = margin(3, 7, 3, 1.5))
lincoln_violin
```

### Strip charts

(ref:lincoln-temp-all-points) Mean daily temperatures in Lincoln, Nebraska, visualized as strip chart. Each point represents the mean temperature for one day. This figure is labeled as "bad" because so many points are plotted on top of each other that it is not possible to ascertain which temperatures were the most common in each month. 

```{r lincoln-temp-all-points, fig.cap = '(ref:lincoln-temp-all-points)'}
lincoln_points <- ggplot(lincoln_df, aes(x = month_short, y = `Mean Temperature [F]`)) +
  geom_point(size = 0.75) + 
  xlab("month") + 
  ylab("mean temperature (°F)") +
  theme_dviz_open() +
  theme(plot.margin = margin(3, 7, 3, 1.5))
stamp_bad(lincoln_points)
```

### Jitter

(ref:lincoln-temp-jittered) Mean daily temperatures in Lincoln, Nebraska, visualized as strip chart. The points have been jittered along the *x* axis to better show the density of points at each temperature value.

```{r lincoln-temp-jittered, fig.cap = '(ref:lincoln-temp-jittered)'}
lincoln_jitter <- ggplot(lincoln_df, aes(x = month_short, y = `Mean Temperature [F]`)) +
  geom_point(position = position_jitter(width = .15, height = 0, seed = 320), size = 0.75) +
  xlab("month") + 
  ylab("mean temperature (°F)") +
  theme_dviz_open() +
  theme(plot.margin = margin(3, 7, 3, 1.5))
lincoln_jitter
```

```{block type='rmdtip', echo=TRUE}
Whenever the dataset is too sparse to justify the violin visualization, plotting the raw data as individual points will be possible.
```

### Violin and strip chart

(ref:lincoln-temp-sina) Mean daily temperatures in Lincoln, Nebraska, visualized as a sina plot (combination of individual points and violins). The points have been jittered along the *x* axis in proportion to the point density at the respective temperature. The name *sina plot* is meant to honor Sina Hadi Sohi, a student at the University of Copenhagen, Denmark, who wrote the first version of the code that researchers at the university used to make such plots (Frederik O. Bagger, personal communication).

```{r lincoln-temp-sina, fig.cap = '(ref:lincoln-temp-sina)'}
lincoln_sina <- ggplot(lincoln_df, aes(x = month_short, y = `Mean Temperature [F]`)) +
  geom_violin(color = "transparent", fill = "gray90") + 
  stat_sina(size = 0.75) + 
  xlab("month") + 
  ylab("mean temperature (°F)") +
  theme_dviz_open() +
  theme(plot.margin = margin(3, 7, 3, 1.5))
lincoln_sina
```

### Ridgeline

(ref:temp-ridgeline) Temperatures in Lincoln, Nebraska, in 2016, visualized as a ridgeline plot. For each month, we show the distribution of daily mean temperatures measured in Fahrenheit. Original figure concept: @Wehrwein-Lincoln-weather.

```{r temp-ridgeline, fig.cap = '(ref:temp-ridgeline)'}
bandwidth <- 3.4
ggplot(lincoln_df, aes(x = `Mean Temperature [F]`, y = `Month`)) +
  geom_density_ridges(
    scale = 3, rel_min_height = 0.01,
    bandwidth = bandwidth, fill = lighten("#56B4E9", .3), color = "white"
  ) +
  scale_x_continuous(
    name = "mean temperature (°F)",
    expand = c(0, 0), breaks = c(0, 25, 50, 75)
  ) +
  scale_y_discrete(name = NULL, expand = c(0, .2, 0, 2.6)) +
  theme_dviz_grid() +
  theme(
    axis.text.y = element_text(vjust = 0),
    plot.margin = margin(3, 7, 3, 1.5)
  )
```

(ref:temp-binline) Temperatures in Lincoln, Nebraska, in 2016, visualized as a ridgeline plot of histograms. The individual histograms don't separate well visually, and the overall figure is quite busy and confusing.

```{r temp-binline, fig.cap = '(ref:temp-binline)'}
bandwidth <- 3.4
p_binline <- ggplot(lincoln_df, aes(x = `Mean Temperature [F]`, y = `Month`)) +
  stat_binline(
    scale = 3, bins = 17, draw_baseline = FALSE,
    fill = lighten("#56B4E9", .3), color = "black", alpha = 1
  ) +
  scale_x_continuous(
    name = "mean temperature (°F)",
    expand = c(0, 0), breaks = c(0, 25, 50, 75)
  ) +
  scale_y_discrete(
    name = NULL,
    expand = c(0, .2, 0, 2.6)
  ) +
  theme_dviz_grid() +
  theme(
    axis.text.y = element_text(vjust = 0),
    plot.margin = margin(3, 7, 3, 1.5)
  )
stamp_ugly(p_binline) 
```

(ref:movies-ridgeline) Evolution of movie lengths over time. Since the 1960s, the majority of all movies are approximately 90 minutes long. Data source: Internet Movie Database, IMDB

```{r movies-ridgeline, fig.width = 5, fig.asp = 1, fig.cap = '(ref:movies-ridgeline)'}
ggplot(movie_lengths, aes(x = length, y = year, group = year)) +
  geom_density_ridges(scale = 10, size = 0.25, rel_min_height = 0.03, fill = "grey85", na.rm = TRUE) +
  scale_x_continuous(limits = c(0, 200), expand = c(0, 0), name = "length (minutes)") +
  scale_y_reverse(
    breaks = c(2000, 1980, 1960, 1940, 1920),
    limits = c(2005, 1903), expand = c(0, 0)
  ) +
  coord_cartesian(clip = "off") +
  theme_dviz_grid() +
  theme(
    plot.margin = margin(3, 14, 3, 1.5)
    )
```

(ref:dw-nominate-ridgeline) Voting patterns in the U.S. House of Representatives have become increasingly polarized. DW-NOMINATE scores are frequently used to compare voting patterns of representatives between parties and over time. Here, score distributions are shown for each Congress from 1963 to 2013 separately for Democrats and Republicans. Each Congress is represented by its first year. Original figure concept: @McDonald-DW-NOMINATE.

```{r dw-nominate-ridgeline, fig.width = 5.5*6/4.2, fig.asp = 0.5, fig.cap = '(ref:dw-nominate-ridgeline)'}
# U.S. House 1963-2013
all_house_88_113 <- dw_nominate_house %>% 
  filter(congress >= 88 & cd !=0 & cd != 98 & cd != 99) %>%
  filter(party_code == 100 | party_code == 200) %>%
  arrange(desc(congress)) %>% mutate(year1 = congress * 2 + 1787) %>%
  arrange(desc(year1))
ggplot(all_house_88_113,
       aes(
         x = dim_1,
         y = year1,
         group = interaction(party_code, factor(year1)),
         fill = interaction(party_code, factor(year1))
        )
      ) +
  geom_density_ridges(scale = 5, size = 0.25, rel_min_height = 0.01, alpha=0.9, color = "white") +
  scale_x_continuous(
    name = "DW-NOMINATE score",
    limits = c(-.8, 1.3),
    breaks = c(-1,-.75,-.5,-.25,0,.25,.5,.75,1)
  ) +
  scale_y_reverse(
    name = "year",
    expand = c(0, 0), breaks=c(seq(2013, 1963, -10))
  ) +
  scale_fill_cyclical(
    breaks = c("100.1963", "200.1963"),
    labels = c(`100.1963` = "Democrats  ", `200.1963` = "Republicans"),
    values = c("#4040ff", "#ff4040", "#6060ff", "#ff6060"),
    name = NULL,
    guide = "legend"
  ) +
  coord_cartesian(clip = "off") +
  theme_dviz_grid() +
  theme(
    axis.text.y = element_text(vjust = 0),
    legend.position = c(1, 1),
    legend.justification = c(1, 1),
    legend.direction = "horizontal",
    legend.background = element_rect(fill = "white")
  )
```

## Proportions

### Pie charts

(ref:bundestag-pie) Party composition of the 8th German Bundestag, 1976--1980, visualized as a pie chart. This visualization shows clearly that the ruling coalition of SPD and FDP had a small majority over the opposition CDU/CSU.

```{r, bundestag-pie, fig.cap='(ref:bundestag-pie)'}
# calculate the start and end angles for each pie
bund_pie <- bundestag %>%
  arrange(seats) %>%
  mutate(
    seat_total = sum(seats),
    end_angle = 2*pi*cumsum(seats)/seat_total,   # ending angle for each pie slice
    start_angle = lag(end_angle, default = 0),   # starting angle for each pie slice
    mid_angle = 0.5*(start_angle + end_angle),   # middle of each pie slice, for the text label
    hjust = ifelse(mid_angle>pi, 1, 0),
    vjust = ifelse(mid_angle<pi/2 | mid_angle>3*pi/2, 0, 1)
  )
rpie = 1
rlabel = 1.05 * rpie
ggplot(bund_pie) + 
  geom_arc_bar(
    aes(
      x0 = 0, y0 = 0, r0 = 0, r = rpie,
      start = start_angle, end = end_angle, fill = party
    ),
    color = "white", size = 0.5
  ) +
  geom_text(
    aes(
      x = rlabel*sin(mid_angle),
      y = rlabel*cos(mid_angle),
      label = party,
      hjust = hjust, vjust = vjust
    ),
    family = dviz_font_family, size = main_size
  ) +
  geom_text(
    aes(
      x = 0.6*sin(mid_angle),
      y = 0.6*cos(mid_angle),
      label = seats
    ),
    family = dviz_font_family, size = main_size,
    color = c("black", "white", "white")
  ) +
  coord_fixed(clip = "off") +
  scale_x_continuous(
    limits = c(-1.5, 1.5),
    expand = c(0, 0),
    name = "",
    breaks = NULL,
    labels = NULL
  ) +
  scale_y_continuous(
    limits = c(-1.01, 1.15),
    expand = c(0, 0),
    name = "",
    breaks = NULL,
    labels = NULL
  ) +
  scale_fill_manual(
    values = bund_pie$colors[order(bund_pie$party)]
  ) +
  theme_dviz_map() +
  theme(
    legend.position = "none",
    plot.margin = margin(3.5, 1.5, 3.5, 1.5)
  )
```

### Rectangular pie

(ref:bundestag-stacked-bars) Party composition of the 8th German Bundestag, 1976--1980, visualized as stacked bars. (a) Bars stacked vertically. (b) Bars stacked horizontally. It is not immediately obvious that SPD and FDP jointly had more seats than CDU/CSU.

```{r, bundestag-stacked-bars, fig.width = 5.5*6/4.2, fig.cap='(ref:bundestag-stacked-bars)'}
bundestag <- mutate(bundestag,
                    label_y = cumsum(seats) - seats/2)
bt_bars_stacked_base <- ggplot(bundestag, aes(x = 1, y = seats, fill = factor(party, levels = rev(party)))) + 
  geom_col(position = "stack", color = "white") + 
  geom_text(
    aes(x = 1., y = label_y, label = seats), 
    size = main_size, family = dviz_font_family,
    color = c("white", "white", "black")
  ) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0), breaks = NULL, name = NULL) +
  scale_fill_manual(values = rev(bundestag$colors), guide = "none")
bt_bars_yax <- axis_canvas(bt_bars_stacked_base, axis = "y") +
  geom_text(
    data = bundestag,
    aes(x = 0.06, y = label_y, label = party),
    hjust = 0, vjust = 0.5, size = small_size,
    family = dviz_font_family
  ) +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 1))
bt_bars_stacked <- insert_yaxis_grob(
  bt_bars_stacked_base + 
    theme_dviz_hgrid() +
    theme(
      axis.ticks = element_line(color = "gray70"),
      plot.margin = margin(7, 1.5, 7, 1.5)
    ),
  bt_bars_yax, grid::unit(.5, "null"))
bt_bars_xax <- axis_canvas(bt_bars_stacked_base, axis = "y") +
  geom_text(
    data = bundestag,
    aes(x = 0., y = label_y, label = party, hjust = 0.5, vjust = 0, size = small_size),
    family = dviz_font_family
  ) +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 1)) +
  coord_flip()
bt_bars_hstacked <- insert_xaxis_grob(
  bt_bars_stacked_base + coord_flip() +
    scale_y_continuous(expand = c(0, 0), position = "right") +
    theme_dviz_vgrid() +
    theme(
      axis.ticks = element_line(color = "gray70"),
      plot.margin = margin(3, 1.5, 3, 3)
    ),
  bt_bars_xax, grid::unit(14, "pt"), position = "bottom")
plot_grid(
  bt_bars_stacked,
  plot_grid(
    NULL, bt_bars_hstacked, NULL,
    ncol = 1, rel_heights = c(1, 6, 7.5)
  ),
  rel_widths = c(4, 7), labels = "auto"
)
```

### Side-by-side

(ref:bundestag-bars-side-by-side) Party composition of the 8th German Bundestag, 1976--1980, visualized as side-by-side bars. As in Figure \@ref(fig:bundestag-stacked-bars), it is not immediately obvious that SPD and FDP jointly had more seats than CDU/CSU.

```{r bundestag-bars-side-by-side, fig.width = 5, fig.asp = 3/4, fig.cap='(ref:bundestag-bars-side-by-side)'}
bt_bars <- ggplot(bundestag, aes(x = factor(party, levels = bundestag$party), y = seats, fill = party)) + 
  geom_col() + 
  geom_text(aes(label = seats), size = main_size, vjust = 2, color = c("white", "white", "black")) +
  scale_x_discrete(name = NULL) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_fill_manual(values = bundestag$colors[order(bundestag$party)], guide = "none") + 
  #geom_hline(yintercept = c(50, 100, 150, 200), color = "#ffffff70", size = .5) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid() +
  theme(
    axis.line.x = element_blank(),
    axis.ticks.x = element_blank()
  )
bt_bars
```

(ref:marketshare-pies) Market share of five hypothetical companies, A--E, for the years 2015--2017, visualized as pie charts. This visualization has two major problems: 1. A comparison of relative market share within years is nearly impossible. 2. Changes in market share across years are difficult to see.

```{r marketshare-pies, fig.width = 5*6/4.2, fig.asp = .35, fig.cap='(ref:marketshare-pies)'}
# calculate the start and end angles for each pie
market_pies_df <- marketshare %>%
  group_by(year) %>%
  mutate(total = sum(percent),
         end_angle = 2*pi*cumsum(percent)/total,      # ending angle for each pie slice
         start_angle = lag(end_angle, default = 0),   # starting angle for each pie slice
         mid_angle = 0.5*(start_angle + end_angle),   # middle of each pie slice, for the text label
         hjust = ifelse(mid_angle>pi, 1, 0),
         vjust = ifelse(mid_angle<pi/2 | mid_angle>3*pi/2, 0, 1))
rpie = 1
rlabel = 1.05 * rpie
market_pies <- ggplot(market_pies_df) + 
  geom_arc_bar(
    aes(
      x0 = 0, y0 = 0, r0 = 0, r = rpie,
      start = start_angle, end = end_angle, fill = company
    ),
    color = NA
  ) +
  geom_text(
    aes(x = rlabel*sin(mid_angle), y = rlabel*cos(mid_angle), label = company, hjust = hjust, vjust = vjust),
    family = dviz_font_family,
    size = small_size
  ) +
  coord_fixed() +
  facet_wrap(~year) +
  scale_x_continuous(limits = c(-1.2, 1.2), expand = c(0, 0), name = NULL, breaks = NULL, labels = NULL) +
  scale_y_continuous(limits = c(-1.2, 1.2), expand = c(0, 0), name = NULL, breaks = NULL, labels = NULL) +
  scale_fill_OkabeIto(order = c(1:3, 5, 4)) + 
  guides(fill = "none") +
  theme_dviz_open() +
  theme(
    axis.line = element_blank(),
    axis.title = element_blank(),
    axis.ticks = element_blank(),
    axis.ticks.length = grid::unit(0, "pt"),
    plot.margin = margin(7, 7, 0, 7),
    legend.position = "none",
    strip.background = element_blank(),
    strip.text.x = element_text(size= 14, margin = margin(0, 0, 0.1, 0))
  )
stamp_bad(market_pies)
```

### Stacked

(ref:marketshare-stacked) Market share of five hypothetical companies for the years 2015--2017, visualized as stacked bars. This visualization has two major problems: 1. A comparison of relative market shares within years is difficult. 2. Changes in market share across years are difficult to see for the middle companies B, C, and D, because the location of the bars changes across years.

```{r marketshare-stacked, fig.cap='(ref:marketshare-stacked)'}
stacked_bars <- ggplot(marketshare, aes(x = year, y = percent, fill = company)) + 
  geom_col(position = "stack") + 
  scale_y_continuous(
    name = "market share",
    labels = scales::percent_format(accuracy = 1, scale = 1),
    expand = c(0, 0)
  ) +
  scale_fill_OkabeIto(order = c(1:3, 5, 4)) + 
  theme_dviz_open() +
  theme(plot.margin = margin(14, 7, 3, 1.5))
stamp_bad(stacked_bars)
```

(ref:marketshare-side-by-side) Market share of five hypothetical companies for the years 2015--2017, visualized as side-by-side bars.

```{r marketshare-side-by-side, fig.cap='(ref:marketshare-side-by-side)'}
ggplot(marketshare, aes(x = company, y = percent, fill = company)) + 
  geom_col() + 
  facet_wrap(~year) +
  scale_y_continuous(
    name = "market share",
    labels = scales::percent_format(accuracy = 1, scale = 1),
    expand = c(0, 0)
  ) +
  scale_fill_OkabeIto(order = c(1:3, 5, 4), guide = "none") + 
  theme_dviz_open() +
  theme(strip.background = element_blank())
```

(ref:women-parliament) Change in the gender composition of the Rwandan parliament over time, 1997 to 2016. Data source: Inter-Parliamentary Union (IPU), ipu.org.

```{r women-parliament, fig.width = 6, fig.asp = .55, fig.cap = '(ref:women-parliament)'}
ccode = "RWA" # Rwanda
#ccode = "BEL" # Belgium
#ccode = "ARB" # Arab world
#ccode = "BOL" # Bolivia
#ccode = "EUU" # European Union
women_parliaments %>% filter(country_code == ccode & year > 1990) %>%
  mutate(women = perc_women, men = 100 - perc_women) %>%
  select(-perc_women) %>%
  gather(gender, percent, women, men) %>%
  mutate(gender = factor(gender, levels = c("women", "men"))) -> women_rwanda
plot_base <- ggplot(women_rwanda, aes(x = year, y = percent, fill = gender)) +
    #geom_col(position = "stack", width = .9, color = "white") +
    geom_col(position = "stack", width = 1, color = "#FFFFFF", size = .75, alpha = 0.8) +
    geom_hline(
      yintercept = c(50),
      color = "#000000FF", size = 0.4, linetype = 2
      #color = "#FFFFFFA0"
    ) +
    geom_hline(yintercept = 100, color = "black") +
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(
      name = "relative proportion",
      labels = scales::percent_format(accuracy = 1, scale = 1),
      expand = c(0, 0)
    ) +
    scale_fill_manual(values = c("#D55E00E0", "#0072B2E0"), guide = "none") +
    coord_cartesian(clip = "off") +
    theme_dviz_open() + 
    theme(
      #axis.ticks.y = element_blank(),
      #axis.ticks.x = element_blank(),
      #axis.line.x = element_blank(),
      axis.line.y = element_blank(),
      plot.margin = margin(14, 1.5, 3, 1.5)
    )
# calculate label position
labels <- filter(women_rwanda, year == max(year)) %>%
  mutate(pos = 100 - cumsum(percent) + 0.5*percent)
yax <- axis_canvas(plot_base, axis = "y") +
  geom_text(data = labels, aes(y = pos, label = paste0(" ", gender)),
            family = dviz_font_family,
            x = 0, hjust = 0, size = 14/2.845276)
ggdraw(insert_yaxis_grob(plot_base, yax, grid::unit(.15, "null")))
```

## Overlapping / Nested proportions

### Nested pie

```{r bridges-pie-wrong, fig.width = 5, fig.asp = 0.7, fig.cap = '(ref:bridges-pie-wrong)'}
# crafts: before 1870
# emerging: 1870 -- 1889
# mature: 1890 -- 1939
# modern: after 1940
select(bridges, MATERIAL, ERECTED) %>%
  table() %>% 
  reshape2::melt() %>%
  rename(material = MATERIAL, erected = ERECTED, count = value) %>%
  mutate(
    material = case_when(
      material == "IRON" ~ "iron",
      material == "STEEL" ~ "steel",
      material == "WOOD" ~ "wood"
    ),
    erected = case_when(
      erected == "CRAFTS" ~ "crafts",
      erected == "EMERGING" ~ "emerging",
      erected == "MATURE" ~ "mature",
      erected == "MODERN" ~ "modern"
   )
  ) %>%
  group_by(erected) %>%
  mutate(group_count = sum(count)) -> bridges_tidy
n_total <- sum(bridges_tidy$count)
bridges_erected <- filter(bridges_tidy, erected %in% c("crafts", "modern")) %>%
  group_by(erected) %>%
  summarize(
    count = sum(count),
    percent = round(100*count/n_total, 1)
  ) %>%
  rename(type = erected)
bridges_material <- group_by(bridges_tidy, material) %>%
  summarize(
    count = sum(count),
    percent = round(100*count/n_total, 1)
  ) %>%
  rename(type = material)
bridges_material_erected <- rbind(bridges_material, bridges_erected) %>%
  mutate(
    type = factor(type, levels = c("steel", "wood", "iron", "modern", "crafts"))
  ) %>%
  arrange(type)
bridges_pie <- bridges_material_erected %>%
  mutate(
    count_total = sum(count),
    end_angle = 2*pi*cumsum(count)/count_total,   # ending angle for each pie slice
    start_angle = lag(end_angle, default = 0),   # starting angle for each pie slice
    mid_angle = 0.5*(start_angle + end_angle),   # middle of each pie slice, for the text label
    hjust = ifelse(mid_angle>pi, 1, 0),
    vjust = ifelse(mid_angle<pi/2 | mid_angle>3*pi/2, 0, 1)
  )
rpie = 1
rlabel = 1.05 * rpie
p_bridges_pie <- ggplot(bridges_pie) + 
  geom_arc_bar(
    aes(
      x0 = 0, y0 = 0, r0 = 0, r = rpie,
      start = start_angle, end = end_angle, fill = type
    ),
    color = "white", size = 0.5
  ) +
  geom_text(
    aes(
      x = rlabel*sin(mid_angle),
      y = rlabel*cos(mid_angle),
      label = type,
      hjust = hjust, vjust = vjust
    ),
    family = dviz_font_family,
    size = 14/.pt
  ) +
  geom_text(
    aes(
      x = 0.6*sin(mid_angle),
      y = 0.6*cos(mid_angle),
      label = paste0(percent, "%")
    ),
    family = dviz_font_family,
    size = 12/.pt,
    color = c("white", "white", "white", "black", "black")
  ) +
  coord_fixed(clip = "off") +
  scale_x_continuous(
    limits = c(-1.5, 1.5), expand = c(0, 0), name = "", breaks = NULL, labels = NULL
  ) +
  scale_y_continuous(
    limits = c(-1.15, 1.15), expand = c(0, 0), name = "", breaks = NULL, labels = NULL
  ) +
  scale_fill_manual(
    values = c(iron = "#D55E00D0", wood = "#009E73D0", steel = "#0072B2D0",
               crafts = "#F0E442D0", modern = "#56B4E9D0")
  ) +
  theme_dviz_map() +
  theme(legend.position = "none")
stamp_wrong(p_bridges_pie)
```

(ref:bridges-bars-bad) Breakdown of bridges in Pittsburgh by construction material (steel, wood, iron) and by date of construction (crafts, before 1870, and modern, after 1940), shown as a bar plot. Unlike Figure \@ref(fig:bridges-pie-wrong), this visualization is not technically wrong, since it doesn't imply that the bar heights need to add up to 100%. However, it also does not clearly indicate the overlap among different groups, and therefore I have labeled it "bad". Data source: Yoram Reich and Steven J. Fenves, via the UCI Machine Learning Repository [@UCI_repo_2017]


```{r bridges-bars-bad, fig.cap = '(ref:bridges-bars-bad)'}
p_bridges_bars <- ggplot(bridges_material_erected) +
  aes(type, percent, fill = type) +
  geom_col() +
  scale_y_continuous(
    limits = c(0, 75),
    expand = c(0, 0),
    labels = function(x) paste0(x, "%"),
    name = "proportion of bridges"
  ) +
  scale_x_discrete(name = NULL) +
  scale_fill_manual(
    values = c(iron = "#D55E00D0", wood = "#009E73D0", steel = "#0072B2D0",
               crafts = "#F0E442D0", modern = "#56B4E9D0")
  ) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid() +
  theme(
    axis.line.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "none",
    plot.margin = margin(3.5, 7, 3.5, 1.5)
  )
stamp_bad(p_bridges_bars)
```

### Mosaic plots and treemaps

(ref:bridges-mosaic) Breakdown of bridges in Pittsburgh by construction material (steel, wood, iron) and by era of construction (crafts, emerging, mature, modern), shown as a mosaic plot. The widths of each rectangle are proportional to the number of bridges constructed in that era, and the heights are proportional to the number of bridges constructed from that material. Numbers represent the counts of bridges within each category. Data source: Yoram Reich and Steven J. Fenves, via the UCI Machine Learning Repository [@UCI_repo_2017]

```{r bridges-mosaic, fig.cap = '(ref:bridges-mosaic)'}
select(bridges, MATERIAL, ERECTED) %>%
  table() %>% 
  reshape2::melt() %>%
  rename(material = MATERIAL, erected = ERECTED, count = value) %>%
  mutate(
    material = case_when(
      material == "IRON" ~ "iron",
      material == "STEEL" ~ "steel",
      material == "WOOD" ~ "wood"
    ),
    erected = case_when(
      erected == "CRAFTS" ~ "crafts",
      erected == "EMERGING" ~ "emerging",
      erected == "MATURE" ~ "mature",
      erected == "MODERN" ~ "modern"
   )
  ) %>%
  group_by(erected) %>%
  mutate(group_count = sum(count)) -> bridges_tidy
labels_df <- group_by(bridges_tidy, erected) %>%
  filter(count != 0) %>%
  arrange(desc(material)) %>%
  mutate(
    y = (cumsum(count) - 0.5*count)/group_count,
    y = ifelse(
      erected == "mature" & material == "wood", NA, y
    )
  )
ggplot(bridges_tidy) +
  aes(x = erected, y = count, width = group_count, fill = material) +
  geom_bar(stat = "identity", position = "fill", colour = "white", size = 1) +
  geom_text(
    data = labels_df,
    aes(y = y, label = count, color = material),
    na.rm = TRUE,
    size = 12/.pt,
    family = dviz_font_family
  ) +
  facet_grid(~erected, scales = "free_x", space = "free_x") +
  scale_y_continuous(
    name = NULL,
    #breaks = NULL,
    expand = c(0, 0),
    breaks = filter(labels_df, erected == "crafts")$y,
    labels = filter(labels_df, erected == "crafts")$material,
    sec.axis = dup_axis(
      breaks = filter(labels_df, erected == "modern")$y,
      labels = filter(labels_df, erected == "modern")$material
    )
  ) +
  scale_x_discrete(
    name = NULL
  ) +
  scale_fill_manual(
    values = c("#D55E00D0", "#0072B2D0", "#009E73D0"), 
    guide = "none"
  ) +
  scale_color_manual(
    values = c(iron = "white", wood = "white", steel = "white"),
    guide = "none"
  ) +
  coord_cartesian(clip = "off") +
  theme_dviz_grid(rel_small = 1) +
  theme(
    line = element_blank(),
    strip.text = element_blank(),
    axis.ticks.length = unit(0, "pt"),
    panel.spacing.x = unit(0, "pt")
  )
```

(ref:bridges-treemap) Breakdown of bridges in Pittsburgh by construction material (steel, wood, iron) and by era of construction (crafts, emerging, mature, modern), shown as a treemap. The area of each rectangle is proportional to the number of bridges of that type. Data source: Yoram Reich and Steven J. Fenves, via the UCI Machine Learning Repository [@UCI_repo_2017]

```{r bridges-treemap, fig.asp = 3/4, fig.cap = '(ref:bridges-treemap)'}
filcols <- c("#D55E00D0", "#0072B2D0", "#009E73D0")
filcols <- c(vapply(filcols, function(x) c(lighten(x, .9), lighten(x, .6), lighten(x, .3), x), character(4)))
ggplot(bridges_tidy, aes(area = count, subgroup = material, fill = interaction(erected, material))) +
  geom_treemap(color = "white", size = 0.5*.pt, alpha = NA) + 
  geom_treemap_subgroup_text(
    family = dviz_font_family,
    colour = "grey50",
    place = "centre", alpha = 0.7,
    grow = TRUE
  ) +
  geom_treemap_subgroup_border(color = "white") +
  geom_treemap_text(
    aes(label = erected, color = interaction(erected, material)),
    family = dviz_font_family,
    place = "centre",
    grow = FALSE
  ) +
  scale_fill_manual(values = filcols) +
  scale_color_manual(values = c(
    crafts.iron = "black", crafts.steel = "black", crafts.wood = "black",
    emerging.iron = "black", emerging.steel = "black", emerging.wood = "black",
    mature.iron = "black", mature.steel = "black", mature.wood = "black",
    modern.iron = "white", modern.steel = "white", modern.wood = "white")
  ) +
  coord_cartesian(clip = "off") +
  guides(colour = "none", fill = "none")
```

## Correlations

(ref:blue-jays-scatter) Head length (measured from the tip of the bill to the back of the head, in mm) versus body mass (in gram), for 123 blue jays. Each dot corresponds to one bird. There is a moderate tendency for heavier birds to have longer heads. Data source: Keith Tarvin, Oberlin College

```{r blue-jays-scatter, fig.width = 5, fig.asp = 3/4, fig.cap='(ref:blue-jays-scatter)'}
ggplot(blue_jays, aes(Mass, Head)) + 
  geom_point(pch = 21, fill = "gray25", color = "white", size = 2.5) +
  scale_x_continuous(name = "body mass (g)") +
  scale_y_continuous(name = "head length (mm)") +
  theme_dviz_grid()
```

(ref:blue-jays-scatter-sex) Head length versus body mass for 123 blue jays. The birds' sex is indicated by color. At the same body mass, male birds tend to have longer heads (and specifically, longer bills) than female birds. Data source: Keith Tarvin, Oberlin College

```{r blue-jays-scatter-sex, fig.width = 5, fig.asp = 3.2/4, fig.cap='(ref:blue-jays-scatter-sex)'}
ggplot(blue_jays, aes(Mass, Head, fill = KnownSex)) + 
  geom_point(pch = 21, color = "white", size = 2.5) +
  scale_x_continuous(name = "body mass (g)") +
  scale_y_continuous(name = "head length (mm)") +
  scale_fill_manual(
    values = c(F = "#D55E00", M = "#0072B2"),
    breaks = c("F", "M"),
    labels = c("female birds   ", "male birds"),
    name = NULL,
    guide = guide_legend(
      direction = "horizontal",
      override.aes = list(size = 3)
      )
    ) +
  theme_dviz_grid() +
  theme(
    #legend.position = c(1, 0.01),
    #legend.justification = c(1, 0),
    legend.position = "top",
    legend.justification = "right",
    legend.box.spacing = unit(3.5, "pt"), # distance between legend and plot
    legend.text = element_text(vjust = 0.6),
    legend.spacing.x = unit(2, "pt"),
    legend.background = element_rect(fill = "white", color = NA),
    legend.key.width = unit(10, "pt")
  )
```


(ref:blue-jays-scatter-bubbles) Head length versus body mass for 123 blue jays. The birds' sex is indicated by color, and the birds' skull size by symbol size. Head-length measurements include the length of the bill while skull-size measurements do not. Head length and skull size tend to be correlated, but there are some birds with unusually long or short bills given their skull size. Data source: Keith Tarvin, Oberlin College


```{r blue-jays-scatter-bubbles, fig.width = 5.5*6/4.2, fig.asp = 3.2/8, fig.cap='(ref:blue-jays-scatter-bubbles)'}
blue_jays$sex <- ifelse(blue_jays$KnownSex == "F", "female birds", "male birds")
blue_jays$sex <- factor(blue_jays$sex, levels = c("female birds", "male birds"))
ggplot(blue_jays, aes(Mass, Head, size = Skull, fill = KnownSex)) + 
  geom_point(pch = 21, color = "white") +
  facet_wrap(~sex, ncol = 2, scales = "fixed") +
  scale_x_continuous(name = "body mass (g)") +
  scale_y_continuous(name = "head length (mm)", breaks = c(52, 54, 56, 58, 60)) +
  scale_fill_manual(values = c(F = "#D55E00", M = "#0072B2"), guide = "none") +
  scale_radius(
    name = "skull size (mm)",
    range = c(2, 7),
    limits = c(28, 34),
    breaks = c(28, 30, 32, 34),
    labels = c("28   ", "30   ", "32   ", "34"),
    guide = guide_legend(
      direction = "horizontal",
      title.position = "top",
      title.hjust = 0.5,
      label.position = "right",
      override.aes = list(fill = "gray40")
    )
  ) +
  theme_dviz_grid(12) +
  theme(
    legend.position = c(1, 0.03),
    legend.justification = c(1, 0),
    legend.spacing.x = unit(2, "pt"),
    legend.spacing.y = unit(2, "pt"),
    legend.background = element_rect(fill = "white", color = NA),
    legend.key.width = unit(10, "pt"),
    #strip.text = element_text(size = 14, family = "Myriad Pro Semibold")
    strip.text = element_text(size = 12, margin = margin(2, 0, 2, 0)),
    strip.background  = element_rect(
      fill = "grey85", colour = "grey85",
      linetype = 1, size = 0.25
    )
  )
```

(ref:blue-jays-scatter-all) All-against-all scatter plot matrix of head length, body mass, and skull size, for 123 blue jays. This figure shows the exact same data as Figure \@ref(fig:blue-jays-scatter-sex). However, because we are better at judging position than symbol size, correlations between skull size and the other two variables are easier to perceive in the pairwise scatter plots than in Figure \@ref(fig:blue-jays-scatter-sex). Data source: Keith Tarvin, Oberlin College


```{r blue-jays-scatter-all, fig.width = 5*6/4.2, fig.asp = 3/4, fig.cap='(ref:blue-jays-scatter-all)'}
blue_jays %>% select(BirdID, KnownSex, Head, Mass, Skull) %>%
  gather(var_x, val_x, Head:Skull) %>%
  left_join(select(blue_jays, BirdID, Head, Mass, Skull)) %>%
  gather(var_y, val_y, Head:Skull) -> bj_matrix
labels <- c(
  Head = "head length (mm)",
  Mass = "body mass (g)",
  Skull = "skull size (mm)"
)
ggplot(bj_matrix, aes(val_x, val_y, fill = KnownSex)) + 
  geom_point(pch = 21, color = "white", size = 2, stroke = 0.2) +
  scale_x_continuous(
    expand = expand_scale(mult = 0.1),
    breaks = scales::pretty_breaks(4, min.n = 3)
  ) +
  scale_y_continuous(
    expand = expand_scale(mult = 0.1),
    breaks = scales::pretty_breaks(4, min.n = 3)
  ) +
  scale_fill_manual(
    values = c(F = "#D55E00D0", M = "#0072B2D0"),
    breaks = c("F", "M"),
    labels = c("female birds   ", "male birds"),
    name = NULL,
    guide = guide_legend(
      direction = "horizontal",
      override.aes = list(size = 2.5)
      )
    ) +
  labs(x = NULL, y = NULL) +
  facet_grid(
    var_y ~ var_x,
    scales = "free",
    switch = "both",
    labeller = labeller(
      var_x = labels,
      var_y = labels
    )
  ) +
  coord_cartesian(clip = "off") +
  theme_dviz_grid(line_size = 0.3) +
  panel_border(colour = "grey85", size = 0.4) +
  theme(
    strip.placement = "outside",
    strip.text.x = element_text(vjust = 1, margin = margin(0, 0, 0, 0)),
    strip.text.y = element_text(vjust = 0, angle = -90, margin = margin(0, 3.5, 0, 0)),
    legend.box.spacing = grid::unit(0, "pt"),
    legend.text = element_text(vjust = 0.6),
    legend.position = "top",
    legend.justification = "right",
    legend.spacing.x = unit(2, "pt"),
    legend.key.width = unit(10, "pt"),
    plot.margin = margin(3.5, 1.5, 3.5, 1.5)
  )
```

### Correlograms

(ref:correlations) Examples of correlations of different magnitude and direction, with associated correlation coefficient *r*. In both rows, from left to right correlations go from weak to strong. In the top row the correlations are positive (larger values for one quantity are associated with larger values for the other) and in the bottom row they are negative (larger values for one quantity are associated with smaller values for the other). In all six panels, the sets of *x* and *y* values are identical, but the pairings between individual *x* and *y* values have been reshuffled to generate the specified correlation coefficients.

```{r correlations, fig.width = 5*6/4.2, fig.asp = 283/434, fig.cap = '(ref:correlations)'}
r <- c(.2, .6, .9, -.2, -.6, -.9)
labels_df <- tibble(
  r = factor(r, levels = r),
  #label = paste0("r = ", r),
  label = c("r = 0.2", "r = 0.6", "r = 0.9", "r = –0.2", "r = –0.6", "r = –0.9"),
  x = c(-2.3, -2.3, -2.3, 2.3, 2.3, 2.3),
  hjust = c(0, 0, 0, 1, 1, 1),
  y = 2.3
)
ggplot(correlation_examples, aes(x, y)) + 
  geom_point(pch = 21, color = "white", size = 2, fill = "#0072B2") + 
  geom_text(
    data = labels_df,
    aes(label = label, hjust = hjust),
    vjust = 1,
    family = "Myriad Pro",
    size = 14/.pt
  ) +
  facet_wrap(~r) +
  coord_fixed(xlim = c(-2.5, 2.5), ylim = c(-2.5, 2.5), expand = FALSE, clip = "off") +
  theme_dviz_map() +
  theme(
    strip.text = element_blank(),
    panel.spacing = grid::unit(12, "pt"),
    plot.margin = margin(3.5, 1.5, 3.5, 1.5)
  ) +
  panel_border(colour = "grey80", size = 0.5)
```

The correlation coefficient is defined as

$$
r = \frac{\sum_i (x_i - \bar x)(y_i - \bar y)}{\sqrt{\sum_i (x_i-\bar x)^2}\sqrt{\sum_i (y_i-\bar y)^2}},
$$
where $x_i$ and $y_i$ are two sets of observations and $\bar x$ and $\bar y$ are the corresponding sample means. We can make a number of observations from this formula. First, the formula is symmetric in $x_i$ and $y_i$, so the correlation of *x* with *y* is the same as the correlation of *y* with *x*. Second, the individual values $x_i$ and $y_i$ only enter the formula in the context of differences to the respective sample mean, so if we shift an entire dataset by a constant amount, e.g. we replace $x_i$ with $x_i' = x_i + C$ for some constant $C$, the correlation coefficient remains unchanged. Third, the correlation coefficient also remains unchanged if we rescale the data, $x_i' = C x_i$, since the constant $C$ will appear both in the numerator and the denominator of the formula and hence can be cancelled. 

Visualizations of correlation coefficients are called *correlograms*. To illustrate the use of a correlogram, we will consider a data set of over 200 glass fragments obtained during forensic work. For each glass fragment, we have measurements about its composition, expressed as the percent in weight of various mineral oxides. There are seven different oxides for which we have measurements, yielding a total of 6 + 5 + 4 + 3 + 2 + 1 = 21 pairwise correlations. We can display these 21 correlations at once as a matrix of colored tiles, where each tile represents one correlation coefficient (Figure \@ref(fig:forensic-correlations1)). This correlogram allows us to quickly grasp trends in the data, such as that magnesium is negatively correlated with nearly all other oxides, and that aluminum and barium have a strong positive correlation.

(ref:forensic-correlations1) Correlations in mineral content for 214 samples of glass fragments obtained during forensic work. The dataset contains seven variables measuring the amounts of magnesium (Mg), calcium (Ca), iron (Fe), potassium (K), sodium (Na), aluminum (Al), and barium (Ba) found in each glass fragment. The colored tiles represents the correlations between pairs of these variables. Data source: B. German

```{r forensic-correlations1, fig.width = 4., fig.asp = 1, fig.cap = '(ref:forensic-correlations1)'}
cm <- cor(select(forensic_glass, -type, -RI, -Si))
df_wide <- as.data.frame(cm)
df_long <- stack(df_wide)
names(df_long) <- c("cor", "var1")
df_long <- cbind(df_long, var2 = rep(rownames(cm), length(rownames(cm))))
clust <- hclust(as.dist(1-cm), method="average") 
levels <- clust$labels[clust$order]
df_long$var1 <- factor(df_long$var1, levels = levels)
df_long$var2 <- factor(df_long$var2, levels = levels)
ggplot(filter(df_long, as.integer(var1) < as.integer(var2)),
       aes(var1, var2, fill=cor)) + 
  geom_tile(color = "white", size = 1) + 
  scale_x_discrete(position = "top", name = NULL, expand = c(0, 0)) +
  scale_y_discrete(name = NULL, expand = c(0, 0)) +
  scale_fill_continuous_divergingx(
    palette = "Earth", rev = FALSE,
    limits = c(-.5, .5),
    breaks = c(-.5, 0, .5),
    labels = c("–0.5", "0.0", "0.5"),
    name = "correlation",
    guide = guide_colorbar(
      direction = "horizontal",
      label.position = "bottom",
      title.position = "top",
      barwidth = grid::unit(140, "pt"),
      barheight = grid::unit(17.5, "pt"),
      ticks.linewidth = 1
    )
  ) +
  coord_fixed() +
  theme_dviz_open(rel_small = 1) +
  theme(
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    axis.ticks.length = grid::unit(3, "pt"),
    legend.position = c(.97, .0),
    legend.justification = c(1, 0),
    legend.title.align = 0.5
  )
```

One weakness of the correlogram of Figure \@ref(fig:forensic-correlations1) is that low correlations, i.e. correlations with absolute value near zero, are not as visually suppressed as they should be. For example, magnesium (Mg) and potassium (K) are not at all correlated but Figure \@ref(fig:forensic-correlations1) doesn't immediately show this. To overcome this limitation, we can display the correlations as colored circles and scale the circle size with the absolute value of the correlation coefficient (Figure \@ref(fig:forensic-correlations1)). In this way, low correlations are suppressed and high correlations stand out better.

(ref:forensic-correlations2) Correlations in mineral content for forensic glass samples. The color scale is identical to Figure \@ref(fig:forensic-correlations1). However, now the magnitude of each correlation is also encoded in the size of the colored circles. This choice visually deemphasizes cases with correlations near zero. Data source: B. German

```{r forensic-correlations2, fig.width = 4., fig.asp = 1, fig.cap = '(ref:forensic-correlations2)'}
ggplot(filter(df_long, as.integer(var1) < as.integer(var2)),
       aes(var1, var2, fill=cor, size = abs(cor))) + 
  geom_point(shape = 21, stroke = 0) + 
  scale_x_discrete(position = "top", name = NULL, expand = c(0, 0.5)) +
  scale_y_discrete(name = NULL, expand = c(0, 0.5)) +
  scale_size_area(max_size = 19, limits = c(0, 0.5), guide = "none") +
  scale_fill_continuous_divergingx(
    palette = "Earth", rev = FALSE,
    limits = c(-.5, .5),
    breaks = c(-.5, 0, .5),
    labels = c("–0.5", "0.0", "0.5"),
    name = "correlation",
    guide = guide_colorbar(
      direction = "horizontal",
      label.position = "bottom",
      title.position = "top",
      barwidth = grid::unit(140, "pt"),
      barheight = grid::unit(17.5, "pt"),
      ticks.linewidth = 1
    )
  ) +
  coord_fixed() +
  theme_dviz_open(rel_small = 1) +
  theme(
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    axis.ticks.length = grid::unit(3, "pt"),
    legend.position = c(.97, .0),
    legend.justification = c(1, 0),
    legend.title.align = 0.5
  )
```

### Dimension reduction (PCA)

(ref:blue-jays-PCA) Example principal components (PC) analysis in two dimensions. (a) The original data. As example data, I am using the head-length and skull-size measurements from the blue jays dataset. Female and male birds are distinguished by color, but this distinction has no effect on the PC analysis. (b) As the first step in PCA, we scale the original data values to zero mean and unit variance. We then we define new variables (the principal components, PCs) along the directions of maximum variation in the data. (c) Finally, we project the data into the new coordinates. Mathematically, this projection is equivalent to a rotation of the data points around the origin. In the 2D example shown here, the data points are rotated clockwise by 45 degrees. 

```{r blue-jays-PCA, fig.width = 5.5*6/4.2, fig.asp = 0.35, fig.cap = '(ref:blue-jays-PCA)'}
p1 <- ggplot(blue_jays, aes(Skull, Head, fill = KnownSex)) + 
  geom_point(pch = 21, color = "white", size = 2, stroke = 0.2) +
  scale_x_continuous(
    name = "skull size (mm)", limits = c(26, 36),
    breaks = c(26, 28, 30, 32, 34, 36)
  ) +
  scale_y_continuous(
    name = "head length (mm)", limits = c(51, 61),
    breaks = c(52, 54, 56, 58, 60)
  ) +
  scale_fill_manual(
    values = c(F = "#D55E00", M = "#0072B2"),
    breaks = c("F", "M"),
    labels = c("female birds   ", "male birds"),
    name = NULL,
    guide = guide_legend(
      direction = "horizontal",
      override.aes = list(size = 3)
      )
    ) +
  coord_fixed() +
  theme_dviz_grid(12) +
  theme(
    legend.position = "top",
    legend.justification = "right",
    legend.box.spacing = unit(3.5, "pt"), # distance between legend and plot
    legend.text = element_text(vjust = 0.6),
    legend.spacing.x = unit(2, "pt"),
    legend.background = element_rect(fill = "white", color = NA),
    legend.key.width = unit(10, "pt")
  )
bj_standard <- data.frame(
  Skull = scale(blue_jays$Skull),
  Head = scale(blue_jays$Head),
  KnownSex = blue_jays$KnownSex
)
df_arrows <- data.frame(
  x = c(-3, 2),
  y = c(-3, -2),
  xend = c(3, -2),
  yend = c(3, 2)
)
df_labels <- data.frame(
  x = c(3.1, -2.1),
  y = c(3.1, 2.1),
  hjust = c(0, 1),
  vjust = c(0, 0),
  label = c("PC 1", "PC 2")
)
p2 <- ggplot(bj_standard, aes(Skull, Head, fill = KnownSex)) + 
  geom_point(pch = 21, color = "white", size = 2, stroke = 0.2) +
  geom_segment(
    data = df_arrows,
    aes(x = x, y = y, xend = xend, yend = yend),
    color = "black",
    arrow = arrow(angle = 15, length = grid::unit(9, "pt"), type = "closed"),
    inherit.aes = FALSE
  ) +
  geom_text(
    data = df_labels,
    aes(x = x, y = y, hjust = hjust, vjust = vjust, label = label),
    size = 12/.pt,
    family = dviz_font_family,
    color = "black", inherit.aes = FALSE
  ) +
  scale_x_continuous(
    name = "skull size (scaled)", limits = c(-4, 4),
    breaks = c(-4, -2, 0, 2, 4), labels = c("-4.0", "-2.0", "0.0", "2.0", "4.0")
  ) +
  scale_y_continuous(
    name = "head length (scaled)", limits = c(-4, 4),
    breaks = c(-4, -2, 0, 2, 4), labels = c("-4.0", "-2.0", "0.0", "2.0", "4.0")
  ) +
  scale_fill_manual(
    values = c(F = "#D55E00", M = "#0072B2"),
    breaks = c("F", "M"),
    labels = c("", ""),
    name = NULL,
    guide = guide_legend(
      direction = "horizontal",
      override.aes = list(shape = NA)
      )
    ) +
  coord_fixed(ratio = 1) +
  theme_dviz_grid(12) +
  theme(
    legend.position = "top",
    legend.justification = "right",
    legend.box.spacing = unit(3.5, "pt"), # distance between legend and plot
    legend.text = element_text(vjust = 0.6),
    legend.spacing.x = unit(2, "pt"),
    legend.background = element_rect(fill = "white", color = NA),
    legend.key.width = unit(10, "pt")
  )
df_arrows <- data.frame(
  x = c(-5.2, 0),
  y = c(0, -3.5),
  xend = c(5.2, 0),
  yend = c(0, 3.5)
)
df_labels <- data.frame(
  x = c(5.2, 0),
  y = c(0.4, 3.8),
  hjust = c(0.9, 0.5),
  vjust = c(0, 0),
  label = c("PC 1", "PC 2")
)
p3 <- ggplot(bj_standard, aes(Skull + Head, -Skull + Head, fill = KnownSex)) + 
  geom_point(pch = 21, color = "white", size = 2, stroke = 0.2) +
  geom_segment(
    data = df_arrows,
    aes(x = x, y = y, xend = xend, yend = yend),
    color = "black",
    arrow = arrow(angle = 15, length = grid::unit(9, "pt"), type = "closed"),
    inherit.aes = FALSE
  ) +
  geom_text(
    data = df_labels,
    aes(x = x, y = y, hjust = hjust, vjust = vjust, label = label),
    size = 12/.pt,
    family = dviz_font_family,
    color = "black", inherit.aes = FALSE
  ) +
  scale_x_continuous(
    name = "PC 1", limits = c(-5.2, 5.2),
    breaks = c(-5, -2.5, 0, 2.5, 5), labels = c("-5.0", "-2.5", "0.0", "2.5", "5.0")
) +
  scale_y_continuous(
    name = "PC 2", limits = c(-5.2, 5.2),
    breaks = c(-5, -2.5, 0, 2.5, 5), labels = c("-5.0", "-2.5", "0.0", "2.5", "5.0")
  ) +
  scale_fill_manual(
    values = c(F = "#D55E00", M = "#0072B2"),
    breaks = c("F", "M"),
    labels = c("", ""),
    name = NULL,
    guide = guide_legend(
      direction = "horizontal",
      override.aes = list(shape = NA)
      )
    ) +
  coord_fixed(ratio = 1) +
  theme_dviz_grid(12) +
  theme(
    legend.position = "top",
    legend.justification = "right",
    legend.box.spacing = unit(3.5, "pt"), # distance between legend and plot
    legend.text = element_text(vjust = 0.6),
    legend.spacing.x = unit(2, "pt"),
    legend.background = element_rect(fill = "white", color = NA),
    legend.key.width = unit(10, "pt")
  )
plot_grid(
  p1, NULL, p2, NULL, p3,
  nrow = 1, align = 'hv', rel_widths = c(1, .04, 1, .04, 1),
  labels = c("a", "", "b", "", "c"), label_y = 0.985
)
```

When we perform PCA, we are generally interested in two pieces of information: (i) the composition of the PCs and (ii) the location of the individual data points in the principal components space. Let's look at these two pieces in a PC analysis of the forensic glass dataset.

First, we look at the component composition (Figure \@ref(fig:forensic-PCA-rotation)). Here, we only consider the first two components, PC 1 and PC 2. Because the PCs are linear combinations of the original variables (after standardization), we can represent the original variables as arrows indicating to what extent they contribute to the PCs. Here, we see that barium and sodium contribute primarily to PC 1 and not to PC 2, calcium and potassium contribute primarily to PC 2 and not to PC 1, and the other variables contribute in varying amounts to both components (Figure \@ref(fig:forensic-PCA-rotation)). The arrows are of varying lengths because there are more than two PCs. For example the arrow for iron is particularly short because it contributes primarily to higher-order PCs (not shown).

(ref:forensic-PCA-rotation) Composition of the first two components in a principal components analysis (PCA) of the forensic glass dataset. Component one (PC 1) measures primarily the amount of aluminum, barium, sodium, and magnesium contents in a glass fragment, whereas component two (PC 2) measures primarily the amount of calcium and potassium content, and to some extent the amount of aluminum and magnesium.

```{r forensic-PCA-rotation, fig.width = 4.5, fig.asp = 1, fig.cap = '(ref:forensic-PCA-rotation)'}
select(forensic_glass, -type, -RI, -Si) %>%
  scale() %>%
  prcomp() -> pca
pca_data <- data.frame(pca$x, type = forensic_glass$type) %>%
  mutate(type = case_when(
    type == "WinF" ~ "window",
    type == "WinNF" ~ "window",
    type == "Veh" ~ "window",
    type == "Con" ~ "container",
    type == "Tabl" ~ "tableware",
    type == "Head" ~ "headlamp"
  )) %>%
  mutate(type = factor(type, levels = c("headlamp", "tableware", "container", "window")))
colors = darken(c("#D55E00", "#0072B2", "#009E73", "#E69F00"), .3)
fills = c("#D55E0040", "#0072B240", "#009E7340", "#E69F0040")
rotation_data <- data.frame(pca$rotation, type = row.names(pca$rotation))
rotation_labels <- data.frame(type = c("Ba", "Al", "Na", "K", "Fe", "Ca", "Mg"),
                              hjust = c(1, 1, 1, 0.5, 0, 0.5, 0),
                              vjust = c(0.5, 0.5, 1, 1, 0.5, 0, 0.5),
                              nudge_x = c(-0.01, -0.01, 0.01, 0, .01, 0, .01),
                              nudge_y = c(0, 0, -.01, -.01, 0, .01, 0))
rotation_data <- left_join(rotation_data, rotation_labels, by = "type")
arrow_style <- arrow(
  angle = 15, length = grid::unit(9, "pt"),
  type = "closed"
)
ggplot(rotation_data) + 
  geom_segment(aes(xend = PC1, yend = PC2),
               x = 0, y = 0,
               arrow = arrow_style,
               color = "#0072B2",
               fill = "#0072B2") + 
  geom_text(aes(x = PC1 + nudge_x, y = PC2 + nudge_y, label = type,
                hjust = hjust, vjust = vjust),
            size = 12/.pt, color = darken('#D55E00', .3),
            family = dviz_font_family) + 
  scale_x_continuous(limits = c(-.8, .8), name = "PC 1") + 
  scale_y_continuous(limits = c(-.7, .8), breaks = c(-0.5, 0, .5),
                     name = "PC 2") +
  coord_fixed() +
  theme_dviz_grid()
```

Next, we project the original data into the principal components space (Figure \@ref(fig:forensic-PCA)). We see a clear clustering of distinct types of glass fragments in this plot. Fragments from both headlamps and windows fall into clearly delineated regions in the PC plot, with few outliers. Fragments from tableware and from containers are a little more spread out, but nevertheless clearly distinct from both headlamp and window fragments. By comparing Figure \@ref(fig:forensic-PCA) with Figure \@ref(fig:forensic-PCA-rotation), we can conclude that window samples tend to have higher than average magnesium content and lower than average barium, aluminum, and sodium content, whereas the opposite is true for headlamp samples.

(ref:forensic-PCA) Composition of individual glass fragments visualized in the principal components space defined in Figure \@ref(fig:forensic-PCA-rotation). We see that the different types of glass samples cluster at characteristic values of PC 1 and 2. In particular, headlamps are characterized by a negative PC 1 value whereas windows tend to have a positive PC 1 value. Tableware and containers have PC 1 values close to zero and tend to have positive PC 2 values. However, there are a few exceptions where container fragments have both a negative PC 1 value and a negative PC 2 value. These are fragments whose composition drastically differs from all other fragments analyzed.


```{r forensic-PCA, fig.width = 5*6/4.2, fig.cap = '(ref:forensic-PCA)'}
ggplot(pca_data, aes(x = PC1, y = PC2, color = type, fill = type, shape = type)) + 
  geom_point(size = 2) +
  scale_color_manual(values = colors, name = "fragment type") +
  scale_fill_manual(values = fills, name = "fragment type") +
  scale_shape_manual(values = c(22:24, 21), name = "fragment type") +
  scale_x_continuous(name = "PC 1") +
  scale_y_continuous(name = "PC 2") +
  theme_dviz_grid()
```

## Paired data {#associations-paired-data}

A special case of multivariate quantitative data is paired data: Data where there are two or more measurements of the same quantity under slightly different conditions. Examples include two comparable measurements on each subject (e.g., the length of the right and the left arm of a person), repeat measurements on the same subject at different time points (e.g., a person's weight at two different times during the year), or measurements on two closely related subjects (e.g., the heights of two identical twins). For paired data, it is reasonable to assume that the two measurements belonging to a pair are more similar to each other than to the measurements belonging to other pairs. Two twins will be approximately of the same height but will differ in height from other twins. Therefore, for paired data, we need to choose visualizations that highlight any differences between the paired measurements.

An excellent choice in this case is a simple scatter plot on top of a diagonal line marking *x* = *y*. In such a plot, if the only difference between the two measurements of each pair is random noise, then all points in the sample will be scattered symmetrically around this line. Any systematic differences between the paired measurements, by contrast, will be visible in a systematic shift of the data points up or down relative to the diagonal. As an example, consider the carbon dioxide (CO<sub>2</sub>) emissions per person, measured for 166 countries both in 1970 and in 2010 (Figure \@ref(fig:CO2-paired-scatter)). This example highlights two common features of paired data. First, most points are relatively close to the diagonal line. Even though CO<sub>2</sub> emissions vary over nearly four orders of magnitude among countries, they are fairly consistent within each country over a 40-year time span. Second, the points are systematically shifted upwards relative to the diagonal line. The majority of countries has seen an increase in CO<sub>2</sub> emissions over the 40 years considered.

(ref:CO2-paired-scatter) Carbon dioxide (CO<sub>2</sub>) emissions per person in 1970 and 2010, for 166 countries. Each dot represents one country. The diagonal line represents identical CO<sub>2</sub> emissions in 1970 and 2010. The points are systematically shifted upwards relative to the diagonal line: In the majority of countries, emissions were higher in 2010 than in 1970. Data source: Carbon Dioxide Information Analysis Center

```{r CO2-paired-scatter, fig.width = 5, fig.asp = 0.9, fig.cap = '(ref:CO2-paired-scatter)'}
CO2_emissions %>% filter(year %in% c(1970, 2010)) %>%
  spread(year, emissions) %>% na.omit() -> emissions_1970_2010
df_segment <- data.frame(
  x = c(0.01, 0.008), 
  xend = c(100, 0.008),
  y = c(0.008, 0.01),
  yend = c(0.008, 100)
)
ggplot(emissions_1970_2010, aes(`1970`, `2010`)) + 
  geom_abline(slope = 1, color = "grey") +
  geom_point(pch = 21, fill = "#0072B2D0", color = "white", size = 2, stroke = 0.3) + 
  geom_segment(
    data = df_segment,
    aes(x = x, xend = xend, y = y, yend = yend),
    size = 0.5,
    inherit.aes = FALSE
  ) +
  scale_x_log10(
    limits = c(0.008, 125),
    breaks = c(0.01, 0.1, 1, 10, 100),
    labels = c("0.01", "0.1", "1.0", "10", "100"),
    #name = "1970 CO2 emissions (tons / person)"
    name = parse(text = "`1970 CO`[2]*` emissions (tons / person)`")
  ) + 
  scale_y_log10(
    limits = c(0.008, 125),
    breaks = c(0.01, 0.1, 1, 10, 100),
    labels = c("0.01", "0.1", "1.0", "10", "100"),
    #name = "2010 CO2 emissions (tons / person)"
    name = parse(text = "`2010 CO`[2]*` emissions (tons / person)`")
  ) +
  coord_fixed(expand = FALSE, clip = "off") +
  theme_dviz_open() +
  theme(axis.line = element_blank())
```

Scatter plots such as Figure \@ref(fig:CO2-paired-scatter) work well when we have a large number of data points and/or are interested in a systematic deviation of the entire data set from the null expectation. By contrast, if we have only a small number of observations and are primarily interested in the identity of each individual case, a *slopegraph* may be a better choice. In a slopegraph, we draw individual measurements as dots arranged into two columns and indicate pairings by connecting the paired dots with a line. The slope of each line highlights the magnitude and direction of change. Figure \@ref(fig:CO2-slopegraph) uses this approach to show the ten countries with the largest difference in CO<sub>2</sub> emissions per person from 2000 to 2010.

(ref:CO2-slopegraph) Carbon dioxide (CO<sub>2</sub>) emissions per person in 2000 and 2010, for the ten countries with the largest difference between these two years. Data source: Carbon Dioxide Information Analysis Center

```{r CO2-slopegraph, fig.width = 4.5, fig.asp = 1, fig.cap = '(ref:CO2-slopegraph)'}
CO2_emissions %>% filter(year %in% c(2000, 2005, 2010)) %>%
  spread(year, emissions) %>% 
  na.omit() %>%
  mutate(diff = `2010` - `2000`, absdiff = abs(diff)) %>%
  arrange(desc(absdiff)) -> emissions_diff
emissions_diff[1:10,] %>% select(-diff) %>% 
  gather(year, emissions, `2000`:`2010`) %>%
  mutate(year = as.numeric(year)) -> emissions_top_ten
textcol <- "gray30"
labels_df <- filter(emissions_top_ten, year == 2010) %>%
  left_join(
    tibble(
      country = c("Trinidad and Tobago", "Qatar", "United Arab Emirates", "Oman", "Bahrain", "Singapore", "Netherlands Antilles", "Kazakhstan", "Equatorial Guinea", "Kuwait"),
      nudge_y = c(.1, .1, .1, .1, -.3, .1, .7, .1, .1, .1)
    )
  )
ggplot(filter(emissions_top_ten, year != 2005), aes(x = year, y = emissions)) +
  geom_line(aes(group = country), color = "gray60") +
  geom_point(color = "white", size = 4) +
  geom_point(color = "#0072B2", size = 2) +
  geom_text(
    data = labels_df,
    aes(x = year + 0.45, y = emissions + nudge_y, label = country),
    family = "Myriad Pro",
    size = 10/.pt,
    hjust = 0) +
  scale_x_continuous(
    limits = c(2000, 2020), breaks = c(2000, 2010),
    labels = c("2000", "2010"),
    expand = expand_scale(add = c(1, 0)),
    name = NULL,
    position = "top"
  ) +
  scale_y_continuous(
    limits = c(0, 63.2),
    expand = c(0, 0),
    #name = "CO2 emissions (tons / person)"
    name = parse(text = "`CO`[2]*` emissions (tons / person)`")
  ) +
  theme_dviz_open() +
  theme(
    axis.line.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.y = element_text(color = textcol),
    axis.text.y = element_text(color = textcol),
    axis.line.y.left = element_line(color = textcol),
    axis.text.y.right = element_text(
      hjust = 0, vjust = .5,
      margin = margin(0, 0, 0, 0),
      color = "black",
      lineheight = 0.8
    ),
    axis.line.y.right = element_blank(),
    axis.ticks.y.right = element_blank(),
    plot.margin = margin(3.5, 1.5, 7, 1.5)
  )
```

## Time series

(ref:biorxiv-dots) Monthly submissions to the preprint server bioRxiv, from its inception in November 2014 until April 2018. Each dot represents the number of submissions in one month. There has been a steady increase in submission volume throughout the entire 4.5-year period. Data source: Jordan Anaya, http://www.prepubmed.org/

```{r biorxiv-dots, fig.cap = '(ref:biorxiv-dots)'}
preprint_growth %>% filter(archive == "bioRxiv") %>%
  filter(count > 0) -> biorxiv_growth
ggplot(biorxiv_growth, aes(date, count)) + 
  #geom_point(color = "#0072B2") +
  geom_point(color = "white", fill = "#0072B2", shape = 21, size = 2) +
  scale_y_continuous(limits = c(0, 1600), expand = c(0, 0),
                name = "preprints / month") + 
  scale_x_date(name = "year") +
  theme_dviz_open() +
  theme(plot.margin = margin(7, 7, 3, 1.5))
```

(ref:biorxiv-dots-line) Monthly submissions to the preprint server bioRxiv, shown as dots connected by lines. The lines do not represent data but are only meant as a guide to the eye. By connecting the individual dots with lines, we emphasize that there is an order between the dots, each dot has exactly one neighbor that comes before and one that comes after. Data source: Jordan Anaya, http://www.prepubmed.org/

```{r biorxiv-dots-line, fig.cap = '(ref:biorxiv-dots-line)'}
ggplot(biorxiv_growth, aes(date, count)) +
  geom_line(size = 0.5, color = "#0072B2") + 
  geom_point(color = "white", fill = "#0072B2", shape = 21, size = 2) +
  scale_y_continuous(limits = c(0, 1600), expand = c(0, 0),
                name = "preprints / month") + 
  scale_x_date(name = "year") +
  theme_dviz_open() +
  theme(plot.margin = margin(7, 7, 3, 1.5))
```

(ref:biorxiv-line) Monthly submissions to the preprint server bioRxiv, shown as a line graph without dots. Omitting the dots emphasizes the overall temporal trend while de-emphasizing individual observations at specific time points. It is particularly useful when the time points are spaced very densely. Data source: Jordan Anaya, http://www.prepubmed.org/

```{r biorxiv-line, fig.cap = '(ref:biorxiv-line)'}
ggplot(biorxiv_growth, aes(date, count)) + geom_line(color = "#0072B2", size = 1) +
  scale_y_continuous(limits = c(0, 1600), expand = c(0, 0),
                name = "preprints / month") + 
  scale_x_date(name = "year") +
  theme_dviz_open() +
  theme(plot.margin = margin(7, 7, 3, 1.5))
```

(ref:biorxiv-line-area) Monthly submissions to the preprint server bioRxiv, shown as a line graph with filled area underneath. By filling the area under the curve, we put even more emphasis on the overarching temporal trend than if we just draw a line (Figure \@ref(fig:biorxiv-line)). Data source: Jordan Anaya, http://www.prepubmed.org/

```{r biorxiv-line-area, fig.cap = '(ref:biorxiv-line-area)'}
ggplot(biorxiv_growth, aes(date, height = count, y = 0)) + 
  geom_ridgeline(color = "#0072B2", fill = "#0072B240", size = 0.75) +
  scale_y_continuous(limits = c(0, 1600), expand = c(0, 0),
                name = "preprints / month") + 
  scale_x_date(name = "year") +
  theme_dviz_open() +
  theme(plot.margin = margin(7, 7, 3, 1.5))
```

### Multiple time series

(ref:bio-preprints-dots) Monthly submissions to three preprint servers covering biomedical research: bioRxiv, the q-bio section of arXiv, and PeerJ Preprints. Each dot represents the number of submissions in one month to the respective preprint server. This figure is labeled "bad" because the three time courses visually interfere with each other and are difficult to read. Data source: Jordan Anaya, http://www.prepubmed.org/

```{r bio-preprints-dots, fig.cap = '(ref:bio-preprints-dots)'}
preprint_growth %>% filter(archive %in% c("bioRxiv", "arXiv q-bio", "PeerJ Preprints")) %>%
  filter(count > 0) %>%
  mutate(archive = factor(archive, levels = c("bioRxiv", "arXiv q-bio", "PeerJ Preprints")))-> preprints
p <- ggplot(preprints, aes(date, count, color = archive, fill = archive, shape = archive)) + 
  geom_point(color = "white", size = 2) +
  scale_shape_manual(values = c(21, 22, 23),
                     name = NULL) + 
  scale_y_continuous(limits = c(0, 600), expand = c(0, 0),
                name = "preprints / month") + 
  scale_x_date(name = "year",
               limits = c(min(biorxiv_growth$date), ymd("2017-01-01"))) +
  scale_color_manual(values = c("#0072b2", "#D55E00", "#009e73"),
                     name = NULL) +
  scale_fill_manual(values = c("#0072b2", "#D55E00", "#009e73"),
                     name = NULL) +
  theme_dviz_open() +
  theme(legend.title.align = 0.5,
        legend.position = c(0.1, .9),
        legend.just = c(0, 1),
        plot.margin = margin(14, 7, 3, 1.5))
stamp_bad(p)
```

(ref:bio-preprints-lines) Monthly submissions to three preprint servers covering biomedical research. By connecting the dots in Figure \@ref(fig:bio-preprints-dots) with lines, we help the viewer follow each individual time course. Data source: Jordan Anaya, http://www.prepubmed.org/

```{r bio-preprints-lines, fig.cap = '(ref:bio-preprints-lines)'}
ggplot(preprints, aes(date, count, color = archive, fill = archive, shape = archive)) + 
  geom_line(size = 0.75) + geom_point(color = "white", size = 2) +
  scale_y_continuous(limits = c(0, 600), expand = c(0, 0),
                name = "preprints / month") + 
  scale_x_date(name = "year",
               limits = c(min(biorxiv_growth$date), ymd("2017-01-01"))) +
  scale_color_manual(values = c("#0072b2", "#D55E00", "#009e73"),
                     name = NULL) +
  scale_fill_manual(values = c("#0072b2", "#D55E00", "#009e73"),
                     name = NULL) +
  scale_shape_manual(values = c(21, 22, 23),
                     name = NULL) + 
  theme_dviz_open() +
  theme(legend.title.align = 0.5,
        legend.position = c(0.1, .9),
        legend.just = c(0, 1),
        plot.margin = margin(14, 7, 3, 1.5))
```

Figure \@ref(fig:bio-preprints-lines) represents an acceptable visualization of the preprints dataset. However, the separate legend creates unnecessary cognitive load. We can reduce this cognitive load by labeling the lines directly (Figure \@ref(fig:bio-preprints-direct-label)). We have also eliminated the individual dots in this figure, for a result that is much more streamlined and easy to read than the original starting point, Figure \@ref(fig:bio-preprints-dots).

(ref:bio-preprints-direct-label) Monthly submissions to three preprint servers covering biomedical research. By direct labeling the lines instead of providing a legend, we have reduced the cognitive load required to read the figure. And the elimination of the legend removes the need for points of different shapes. Thus, we could streamline the figure further by eliminating the dots. Data source: Jordan Anaya, http://www.prepubmed.org/

```{r bio-preprints-direct-label, fig.cap = '(ref:bio-preprints-direct-label)'}
preprints_final <- filter(preprints, date == ymd("2017-01-01"))
ggplot(preprints) +
  aes(date, count, color = archive, fill = archive, shape = archive) + 
  geom_line(size = 1) + 
  #geom_point(color = "white", size = 2) +
  scale_y_continuous(
    limits = c(0, 600), expand = c(0, 0),
    name = "preprints / month",
    sec.axis = dup_axis(
      breaks = preprints_final$count,
      labels = c("arXiv\nq-bio", "PeerJ\nPreprints", "bioRxiv"),
      name = NULL)
  ) + 
  scale_x_date(name = "year",
               limits = c(min(biorxiv_growth$date), ymd("2017-01-01")),
               expand = expand_scale(mult = c(0.02, 0))) +
  scale_color_manual(values = c("#0072b2", "#D55E00", "#009e73"),
                     name = NULL) +
  scale_fill_manual(values = c("#0072b2", "#D55E00", "#009e73"),
                     name = NULL) +
  scale_shape_manual(values = c(21, 22, 23),
                     name = NULL) + 
  coord_cartesian(clip = "off") +
  theme_dviz_open() +
  theme(legend.position = "none") +
  theme(axis.line.y.right = element_blank(),
        axis.ticks.y.right = element_blank(),
        axis.text.y.right = element_text(margin = margin(0, 0, 0, 0)),
        plot.margin = margin(14, 7, 3, 1.5))
```

### Dose response

(ref:oats-yield) Dose--response curve showing the mean yield of oats varieties after fertilization with manure. The manure serves as a source of nitrogen, and oat yields generally increase as more nitrogen is available, regardless of variety. Here, manure application is measured in cwt (hundredweight) per acre. The hundredweight is an old imperial unit equal to 112 lbs or 50.8 kg. Data source: @Yates1935

```{r oats-yield, fig.cap = '(ref:oats-yield)'}
MASS::oats %>% 
  # 1 long (UK) cwt == 112 lbs == 50.802345 kg
  mutate(N = 1*as.numeric(sub("cwt", "", N, fixed = TRUE))) %>%
  group_by(N, V) %>%
  summarize(mean = 20 * mean(Y)) %>% # factor 20 converts units to lbs/acre
  mutate(variety = ifelse(V == "Golden.rain", "Golden Rain", as.character(V))) ->
  oats_df
oats_df$variety <- factor(oats_df$variety, levels = c("Marvellous", "Golden Rain", "Victory"))
 
ggplot(oats_df,
       aes(N, mean, color = variety, shape = variety, fill = variety)) +
  geom_line(size = 0.75) + geom_point(color = "white", size = 2.5) +
  scale_y_continuous(name = "mean yield (lbs/acre)") + 
  scale_x_continuous(name = "manure treatment (cwt/acre)") +
  scale_shape_manual(values = c(21, 22, 23),
                     name = "oat variety") + 
  scale_color_manual(values = c("#0072b2", "#D55E00", "#009e73"),
                     name = "oat variety") +
  scale_fill_manual(values = c("#0072b2", "#D55E00", "#009e73"),
                     name = "oat variety") +
  coord_cartesian(clip = "off") +
  theme_dviz_open() +
  theme(legend.title.align = 0.5)
```

## Visualizing trends

### Smoothing

(ref:dow-jones) Daily closing values of the Dow Jones Industrial Average for the year 2009. Data source: Yahoo! Finance

```{r dow-jones, fig.width = 5*6/4.2, fig.asp = 0.5, fig.cap = '(ref:dow-jones)'}
dow_jones_industrial %>% filter(date >= ymd("2008/12/31") & date <= ymd("2010/01/10")) %>%
  ggplot(aes(date, close)) + 
  geom_line(color = "grey20", size = 0.75) + 
  scale_x_date(limits = c(ymd("2008-12-31"), ymd("2010-01-10")), expand = c(0, 0)) +
  xlab(NULL) + ylab("Dow Jones Industrial Average") +
  theme_dviz_grid() +
  theme(
    plot.margin = margin(3, 12, 3, 1.5)
  )
```

(ref:dow-jones-moving-ave) Daily closing values of the Dow Jones Industrial Average for the year 2009, shown together with their 20-day, 50-day, and 100-day moving averages. (a) The moving averages are plotted at the end of the moving time windows. (b) The moving averages are plotted in the center of the moving time windows. Data source: Yahoo! Finance

```{r dow-jones-moving-ave, fig.width = 5*6/4.2, fig.asp = 1, fig.cap = '(ref:dow-jones-moving-ave)'}
p1 <- dow_jones_industrial %>% filter(date >= ymd("2008/12/31") & date <= ymd("2010/01/10")) %>%
  mutate(
    close_20d_ave = moving_ave(date, close, 20, center = FALSE),
    close_50d_ave = moving_ave(date, close, 50, center = FALSE),
    close_100d_ave = moving_ave(date, close, 100, center = FALSE)
  ) %>%
  ggplot(aes(date, close)) + 
  geom_line(color = "grey20", size = .35) +
  geom_line(aes(date, close_20d_ave, color = "20d"), size = 1, na.rm = TRUE) +
  geom_line(aes(date, close_50d_ave, color = "50d"), size = 1, na.rm = TRUE) +
  geom_line(aes(date, close_100d_ave, color = "100d"), size = 1, na.rm = TRUE) +
  scale_color_manual(
    values = c(
      `20d` = "#009e73",
      `50d` = "#d55e00",
      `100d` = "#0072b2"
    ),
    breaks = c("20d", "50d", "100d"),
    labels = c("20-day average", "50-day average", "100-day average"),
    name = NULL
  ) + 
  scale_x_date(
    limits = c(ymd("2008-12-31"), ymd("2010-01-10")), expand = c(0, 0),
    labels = NULL
  ) +
  xlab(NULL) + ylab("Dow Jones Industrial Average") +
  theme_dviz_grid() +
  theme(
    plot.margin = margin(3, 12, 3, 1.5),
    legend.position = c(1, 0),
    legend.justification = c(1, 0),
    legend.box.background = element_rect(fill = "white", color = NA),
    legend.box.margin = margin(6, 12, 0, 12),
    axis.ticks.x = element_blank()
  )
p2 <- dow_jones_industrial %>% filter(date >= ymd("2008/12/31") & date <= ymd("2010/01/10")) %>%
  mutate(
    close_20d_ave = moving_ave(date, close, 20, center = TRUE),
    close_50d_ave = moving_ave(date, close, 50, center = TRUE),
    close_100d_ave = moving_ave(date, close, 100, center = TRUE)
  ) %>%
  ggplot(aes(date, close)) + 
  geom_line(color = "grey20", size = .35) +
  geom_line(aes(date, close_20d_ave, color = "20d"), size = 1, na.rm = TRUE) +
  geom_line(aes(date, close_50d_ave, color = "50d"), size = 1, na.rm = TRUE) +
  geom_line(aes(date, close_100d_ave, color = "100d"), size = 1, na.rm = TRUE) +
  scale_color_manual(
    values = c(
      `20d` = "#009e73",
      `50d` = "#d55e00",
      `100d` = "#0072b2"
    ),
    breaks = c("20d", "50d", "100d"),
    labels = c("20-day average", "50-day average", "100-day average"),
    name = NULL,
    guide = "none"
  ) + 
  scale_x_date(limits = c(ymd("2008-12-31"), ymd("2010-01-10")), expand = c(0, 0)) +
  xlab(NULL) + ylab("Dow Jones Industrial Average") +
  theme_dviz_grid() +
  theme(
    plot.margin = margin(3, 12, 3, 1.5)
  )
plot_grid(p1, p2, ncol = 1, align = 'h', labels = "auto")
```

(ref:dow-jones-loess) Comparison of LOESS fit to 100-day moving average for the Dow Jones data of Figure \@ref(fig:dow-jones-moving-ave). The overall trend shown by the LOESS smooth is nearly identical to the 100-day moving average, but the LOESS curve is much smoother and it extends to the entire range of the data. Data source: Yahoo! Finance

```{r dow-jones-loess, fig.width = 5*6/4.2, fig.asp = 0.5, fig.cap = '(ref:dow-jones-loess)'}
# LOESS (locally estimated scatterplot smoothing) 
dow_jones_industrial %>% filter(date >= ymd("2008/12/31") & date <= ymd("2010/01/10")) %>%
  mutate(
    close_100d_ave = moving_ave(date, close, 100)
  ) %>%
  ggplot(aes(date, close)) + 
  geom_line(color = "grey20", size = .35) +
  geom_line(aes(date, close_100d_ave, color = "100d"), size = 1, na.rm = TRUE) +
  geom_smooth(aes(color = "smooth"), size = 1, na.rm = TRUE, se = FALSE) +
  scale_color_manual(
    values = c(
      `100d` = "#d55e00",
      smooth = "#0072b2"
    ),
    breaks = c("smooth", "100d"),
    labels = c("LOESS smoother", "100-day average"),
    name = NULL
  ) + 
  scale_x_date(limits = c(ymd("2008-12-31"), ymd("2010-01-10")), expand = c(0, 0)) +
  xlab(NULL) + ylab("Dow Jones Industrial Average") +
  theme_dviz_grid() +
  theme(
    legend.position = c(1, 0.48),
    legend.justification = c(1, 0.5),
    legend.box.background = element_rect(fill = "white", color = NA),
    legend.box.margin = margin(0, 12, 6, 12),
    plot.margin = margin(3, 12, 3, 1.5)
  )
```

(ref:tank-capacity-loess) Fuel-tank capacity versus price of 93 cars released for the 1993 model year. Each dot corresponds to one car. The solid line represents a LOESS smooth of the data. We see that fuel-tank capacity increases approximately linearly with price, up to a price of approximately $20,000, and then it levels off. Data source: Robin H. Lock, St. Lawrence University

```{r tank-capacity-loess, fig.width = 5, fig.asp = 0.75, fig.cap='(ref:tank-capacity-loess)'}
cars93 <- MASS::Cars93
ggplot(cars93, aes(x = Price, y = Fuel.tank.capacity)) + 
  geom_point(color = "grey60") + 
  geom_smooth(se = FALSE, method = "loess", formula = y ~ x, color = "#0072B2") +
  scale_x_continuous(
    name = "price (USD)",
    breaks = c(20, 40, 60),
    labels = c("$20,000", "$40,000", "$60,000")
  ) +
  scale_y_continuous(name = "fuel-tank capacity\n(US gallons)") +
  theme_dviz_grid()
```

(ref:tank-capacity-smoothers) Different smoothing models display widely different behaviors, in particular near the boundaries of the data. (a) LOESS smoother, as in Figure \@ref(fig:tank-capacity-loess). (b) Cubic regression splines with 5 knots. (c) Thin-plate regression spline with 3 knots. (d)  Gaussian process spline with 6 knots. Data source: Robin H. Lock, St. Lawrence University

```{r tank-capacity-smoothers, fig.width = 5.5*6/4.2, fig.asp = 0.75, fig.cap='(ref:tank-capacity-smoothers)'}
cars_base <- ggplot(cars93, aes(x = Price, y = Fuel.tank.capacity)) + geom_point(color = "grey60") + 
  scale_x_continuous(
    name = "price (USD)",
    breaks = c(20, 40, 60),
    labels = c("$20,000", "$40,000", "$60,000")
  ) +
  scale_y_continuous(name = "fuel-tank capacity\n(US gallons)") +
  theme_dviz_grid(12)  
  
p1 <- cars_base + geom_smooth(se = FALSE, method = "loess", formula = y ~ x, color = "#0072B2")
p2 <- cars_base + geom_smooth(se = FALSE, method = "gam", formula = y ~ s(x, k = 5, bs = 'cr'), color = "#0072B2")
p3 <- cars_base + geom_smooth(se = FALSE, method = "gam", formula = y ~ s(x, k = 3), color = "#0072B2")
p4 <- cars_base + geom_smooth(se = FALSE, method = "gam", formula = y ~ s(x, k = 6, bs = 'gp'), color = "#0072B2")
plot_grid(
  p1, NULL, p2,
  NULL, NULL, NULL,
  p3, NULL, p4,
  align = 'hv',
  labels = c("a", "", "b", "", "", "", "c", "", "d"),
  rel_widths = c(1, .02, 1),
  rel_heights = c(1, .02, 1)
)
```

Most data visualization software will provide smoothing features, likely implemented as either a type of local regression (such as LOESS) or a type of spline. The smoothing method may be referred to as a GAM, a generalized additive model, which is a superset of all these types of smoothers. It is important to be aware that the output of the smoothing feature is highly dependent on the specific GAM model that is fit. Unless you try out a number of different choices you may never realize to what extent the results you see depend on the specific default choices made by your statistical software.

```{block type='rmdtip', echo=TRUE}
Be careful when interpreting the results from a smoothing function. The same dataset can be smoothed in many different ways.
```

### Mathematical functions

(ref:tank-capacity-model) Fuel-tank data represented with an explicit analytical model. The solid line corresponds to a least-squares fit of the formula $y = A - B \exp(-mx)$ to the data. Fitted parameters are $A = 19.6$, $B = 29.2$, $m = 0.00015$.  Data source: Robin H. Lock, St. Lawrence University

```{r tank-capacity-model, fig.width = 5, fig.asp = 0.75, fig.cap = '(ref:tank-capacity-model)'}
# first model
fit.out <- nls(
  Fuel.tank.capacity ~ a*Price/(Price + b) + c,
  data = cars93,
  start = c(a = -45, b = -1, c = 70)
)
# second model
fit.out <- nls(
  Fuel.tank.capacity ~ A1 - A0*exp(-m*Price),
  data = cars93,
  start = c(A0 = 29.249, A1 = 19.621, m = 0.149),
  control = nls.control(maxiter = 1000, warnOnly = TRUE)
)
fit.df <- data.frame(
  Price = 7:62,
  Fuel.tank.capacity = predict(fit.out, data.frame(Price = 7:62))
)
ggplot(cars93, aes(x = Price, y = Fuel.tank.capacity)) + 
  geom_point(color = "grey60") + 
  geom_line(data = fit.df, size = 1, color = "#0072B2") +
  #stat_function(fun = function(x) -24.22+1.38*x  + 22) +
  scale_x_continuous(
    name = "price (USD)",
    breaks = c(20, 40, 60),
    labels = c("$20,000", "$40,000", "$60,000")
  ) +
  scale_y_continuous(name = "fuel-tank capacity\n(US gallons)") +
  theme_dviz_grid()
```

(ref:blue-jays-scatter-line) Head length versus body mass for 123 blue jays. The birds' sex is indicated by color. This figure is equivalent to Figure \@ref(fig:blue-jays-scatter-sex), except that now we have drawn linear trend lines on top of the individual data points. Data source: Keith Tarvin, Oberlin College

```{r blue-jays-scatter-line, fig.width = 5, fig.asp = 3.2/4, fig.cap='(ref:blue-jays-scatter-line)'}
ggplot(blue_jays, aes(Mass, Head, color = KnownSex, fill = KnownSex)) + 
  geom_point(pch = 21, color = "white", size = 2.5) +
  geom_smooth(method = "lm", size = 0.75, se = FALSE, fullrange = TRUE) +
  scale_x_continuous(name = "body mass (g)") +
  scale_y_continuous(name = "head length (mm)") +
  scale_fill_manual(
    values = c(F = "#D55E00C0", M = "#0072B2C0"),
    breaks = c("F", "M"),
    labels = c("female birds   ", "male birds"),
    name = NULL,
    guide = guide_legend(
      direction = "horizontal",
      override.aes = list(size = 3, linetype = 0)
    )
  ) +
  scale_color_manual(
    values = c(F = "#D55E00", M = "#0072B2"),
    breaks = c("F", "M"),
    labels = c("female birds   ", "male birds"),
    name = NULL
  ) +
  theme_dviz_grid() +
  theme(
    #legend.position = c(1, 0.01),
    #legend.justification = c(1, 0),
    legend.position = "top",
    legend.justification = "right",
    legend.box.spacing = unit(3.5, "pt"), # distance between legend and plot
    legend.text = element_text(vjust = 0.6),
    legend.spacing.x = unit(2, "pt"),
    legend.background = element_rect(fill = "white", color = NA),
    legend.key.width = unit(10, "pt")
  )
```

(ref:biorxiv-expfit) Monthly submissions to the preprint server bioRxiv. The solid blue line represents the actual monthly preprint counts and the dashed black line represents an exponential fit to the data, $y = 60\exp[0.77(x - 2014)]$. Data source: Jordan Anaya, http://www.prepubmed.org/

```{r biorxiv-expfit, fig.cap = '(ref:biorxiv-expfit)'}
preprint_growth %>% filter(archive == "bioRxiv") %>%
  filter(count > 0) %>%
  mutate(date_dec = decimal_date(date)) -> biorxiv_growth
expfit.out <- nls(
  count ~ a*exp(b*(date_dec-2014)),
  data = biorxiv_growth,
  start = c(a = 60.004, b = .773)
)
linfit.out <- nls(
  log(count) ~ log(a) + b*(date_dec-2014),
  data = biorxiv_growth,
  start = c(a = 42.576, b = .878)
)
date_seq = seq(min(biorxiv_growth$date_dec), max(biorxiv_growth$date_dec), by = 0.1)
expfit.df <- data.frame(
  date_dec = date_seq,
  count = predict(expfit.out, data.frame(date_dec = date_seq))
)
linfit.df <- data.frame(
  date_dec = date_seq,
  count = exp(predict(linfit.out, data.frame(date_dec = date_seq)))
)
ggplot(biorxiv_growth, aes(date_dec, count)) + 
  geom_line(data = expfit.df, aes(color = "expfit"), size = .5, linetype = 2) +
  geom_point(aes(fill = "expfit"), shape = NA, na.rm = TRUE) + # dummy for legend
  geom_line(aes(color = "data"), size = .5) +
  geom_point(aes(fill = "data"), color = "white", shape = 21, size = 2) +
  scale_y_continuous(
     limits = c(0, 1550),
     breaks = c(0, 500, 1000, 1500),
     expand = c(0, 0),
     name = "preprints / month"
  ) + 
  scale_x_continuous(name = NULL) +
  scale_color_manual(
    name = NULL,
    values = c(data = "#0072B2", expfit = "black"),
    breaks = c("data", "expfit"),
    labels = c("actual counts", "exponential fit"),
    guide = guide_legend(
      override.aes = list(
        color = c("white", "black"),
        shape = c(21, NA),
        size = c(2, 0.5),
        linetype = c(0, 2)
      )
    )
  ) +
  scale_fill_manual(
    name = NULL,
    values = c(data = "#0072B2", expfit = "black"),
    breaks = c("data", "expfit"),
    labels = c("actual counts", "exponential fit")
  ) +
  theme_dviz_open() +
  theme(
    legend.position = c(.05, 1),
    legend.justification = c(0, 1),
    legend.spacing.x = unit(3, "pt"),
    legend.title = element_blank(), 
    plot.margin = margin(7, 7, 3, 1.5)
  )
```

(ref:biorxiv-logscale) Monthly submissions to the preprint server bioRxiv, shown on a log scale. The solid blue line represents the actual monthly preprint counts, the dashed black line represents the exponential fit from Figure \@ref(fig:biorxiv-expfit), and the solid black line represents a linear fit to log-transformed data, corresponding to $y = 43\exp[0.88(x - 2014)]$. Data source: Jordan Anaya, http://www.prepubmed.org/

```{r biorxiv-logscale, fig.cap = '(ref:biorxiv-logscale)'}
ggplot(biorxiv_growth, aes(date_dec, count)) +
  geom_line(data = expfit.df, aes(color = "expfit"), size = .5, linetype = 2) +
  geom_point(aes(fill = "expfit"), shape = NA, na.rm = TRUE) + # dummy for legend
  geom_line(data = linfit.df, aes(color = "linfit"), size = .5) +
  geom_point(aes(fill = "linfit"), shape = NA, na.rm = TRUE) + # dummy for legend
  geom_line(aes(color = "data"), size = .5) +
  geom_point(aes(fill = "data"), color = "white", shape = 21, size = 2) +
  scale_y_log10(
    limits = c(30, 1670),
    breaks = c(10*(3:9), 100*(1:9), 1000*(1:2)),
    labels = c(
      "", "", "50", "", "", "", "", "100", "", "", "", "500",
      "", "", "", "", "1000", ""
    ),
    expand = c(0, 0),
    name = "preprints / month"
  ) + 
  scale_x_continuous(name = NULL) +
  scale_color_manual(
    name = NULL,
    values = c(data = "#0072B2", expfit = "black", linfit = "black"),
    breaks = c("data", "expfit", "linfit"),
    labels = c("actual counts", "exponential fit", "linear fit, log-transformed data"),
    guide = guide_legend(
      override.aes = list(
        color = c("white", "black", "black"),
        shape = c(21, NA, NA),
        size = c(2, 0.5, 0.5),
        linetype = c(0, 2, 1)
      )
    )
  ) +
  scale_fill_manual(
    name = NULL,
    values = c(data = "#0072B2", expfit = "black", linfit = "black"),
    breaks = c("data", "expfit", "linfit"),
    labels = c("actual counts", "exponential fit", "linear fit, log-transformed data")
  ) +
  theme_dviz_open() +
  theme(
    legend.position = c(.05, 1),
    legend.justification = c(0, 1),
    legend.spacing.x = unit(3, "pt"),
    legend.title = element_blank(), 
    plot.margin = margin(7, 7, 3, 1.5)
  )
```

```{block type='rmdtip', echo=TRUE}
It is usually better to fit a straight line to transformed data than to fit a nonlinear curve to untransformed data.
```
